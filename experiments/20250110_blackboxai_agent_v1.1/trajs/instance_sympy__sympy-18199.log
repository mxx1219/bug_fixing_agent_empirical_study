

TASK:


nthroot_mod function misses one root of x = 0 mod p.
When in the equation x**n = a mod p , when a % p == 0. Then x = 0 mod p is also a root of this equation. But right now `nthroot_mod` does not check for this condition. `nthroot_mod(17*17, 5 , 17)` has a root `0 mod 17`. But it does not return it.



============================================================



ACTION:

THOUGHT: I'll help you implement the necessary changes following the steps you outlined.

1. First, let's explore the repository structure:
CODE:
get_repo_structure("/workspace/sympy__sympy__1.6")

============================================================



OBSERVATION:

/workspace/sympy__sympy__1.6:
AUTHORS
CODE_OF_CONDUCT.md
CONTRIBUTING.md
LICENSE
MANIFEST.in
PULL_REQUEST_TEMPLATE.md
README.rst
asv.conf.travis.json
bin
codecov.yml
conftest.py
coveragerc_travis
data
doc
examples
github_deploy_key.enc
isympy.py
pytest.ini
release
setup.cfg
setup.py
setupegg.py
sympy
sympy.egg-info

/workspace/sympy__sympy__1.6/bin:
ask_update.py
authors_update.py
coverage_doctest.py
coverage_report.py
diagnose_imports
doctest
generate_module_list.py
generate_test_list.py
get_sympy.py
isympy
mailmap_update.py
py.bench
strip_whitespace
sympy_time.py
sympy_time_cache.py
test
test_executable.py
test_external_imports.py
test_import
test_import.py
test_isolated
test_setup.py
test_travis.sh

/workspace/sympy__sympy__1.6/data:
TeXmacs

/workspace/sympy__sympy__1.6/data/TeXmacs:
LICENSE
bin
progs

/workspace/sympy__sympy__1.6/data/TeXmacs/bin:
tm_sympy

/workspace/sympy__sympy__1.6/data/TeXmacs/progs:
init-sympy.scm

/workspace/sympy__sympy__1.6/doc:
Makefile
README.rst
api
apidoc.conf
cheatsheet
ext
generate_logos.py
man
src

/workspace/sympy__sympy__1.6/doc/api:
conf.py
index.rst

/workspace/sympy__sympy__1.6/doc/cheatsheet:
cheatsheet.tex
combinatoric_cheatsheet.tex

/workspace/sympy__sympy__1.6/doc/ext:
docscrape.py
docscrape_sphinx.py
numpydoc.py
sympylive.py

/workspace/sympy__sympy__1.6/doc/man:
isympy.1
isympy.xml

/workspace/sympy__sympy__1.6/doc/src:
_static
_templates
aboutus.rst
citing.rst
conf.py
documentation-style-guide.rst
gotchas.rst
guide.rst
index.rst
install.rst
logo
modules
outreach.rst
pics
special_topics
tutorial
wiki.rst

/workspace/sympy__sympy__1.6/doc/src/_static:
default.css_t
sympylogo.png
sympylogo_big.png

/workspace/sympy__sympy__1.6/doc/src/_templates:
layout.html

/workspace/sympy__sympy__1.6/doc/src/logo:
info.txt
sympy-use-text.svg
sympy.svg

/workspace/sympy__sympy__1.6/doc/src/modules:
abc.rst
algebras.rst
assumptions
calculus
categories.rst
codegen.rst
combinatorics
concrete.rst
core.rst
crypto.rst
diffgeom.rst
discrete.rst
evalf.rst
functions
geometry
holonomic
index.rst
integrals
interactive.rst
liealgebras
logic.rst
matrices
ntheory.rst
numeric-computation.rst
parsing.rst
physics
plotting.rst
polys
printing.rst
rewriting.rst
series
sets.rst
simplify
solvers
stats.rst
tensor
utilities
vector

/workspace/sympy__sympy__1.6/doc/src/modules/assumptions:
ask.rst
assume.rst
handlers
index.rst
refine.rst

/workspace/sympy__sympy__1.6/doc/src/modules/assumptions/handlers:
calculus.rst
common.rst
index.rst
matrices.rst
ntheory.rst
order.rst
sets.rst

/workspace/sympy__sympy__1.6/doc/src/modules/calculus:
index.rst

/workspace/sympy__sympy__1.6/doc/src/modules/combinatorics:
fp_groups.rst
graycode.rst
group_constructs.rst
index.rst
named_groups.rst
partitions.rst
pc_groups.rst
perm_groups.rst
permutations.rst
polyhedron.rst
prufer.rst
subsets.rst
tensor_can.rst
testutil.rst
util.rst

/workspace/sympy__sympy__1.6/doc/src/modules/functions:
combinatorial.rst
elementary.rst
index.rst
special.rst

/workspace/sympy__sympy__1.6/doc/src/modules/geometry:
curves.rst
ellipses.rst
entities.rst
index.rst
lines.rst
plane.rst
points.rst
polygons.rst
utils.rst

/workspace/sympy__sympy__1.6/doc/src/modules/holonomic:
about.rst
convert.rst
index.rst
internal.rst
operations.rst
represent.rst
uses.rst

/workspace/sympy__sympy__1.6/doc/src/modules/integrals:
g-functions.rst
integrals.rst

/workspace/sympy__sympy__1.6/doc/src/modules/liealgebras:
index.rst

/workspace/sympy__sympy__1.6/doc/src/modules/matrices:
common.rst
dense.rst
expressions.rst
immutablematrices.rst
index.rst
matrices.rst
sparse.rst

/workspace/sympy__sympy__1.6/doc/src/modules/physics:
continuum_mechanics
hep
hydrogen.rst
index.rst
matrices.rst
mechanics
optics
paulialgebra.rst
qho_1d.rst
quantum
secondquant.rst
sho.rst
units
vector
wigner.rst

/workspace/sympy__sympy__1.6/doc/src/modules/physics/continuum_mechanics:
beam.rst
beam_problems.rst
index.rst

/workspace/sympy__sympy__1.6/doc/src/modules/physics/hep:
index.rst

/workspace/sympy__sympy__1.6/doc/src/modules/physics/mechanics:
advanced.rst
api
autolev_parser.rst
examples
examples.rst
index.rst
kane.rst
lagrange.rst
linearize.rst
masses.rst
reference.rst
sympy_mechanics_for_autolev_users.rst
symsystem.rst

/workspace/sympy__sympy__1.6/doc/src/modules/physics/mechanics/api:
body.rst
expr_manip.rst
kane_lagrange.rst
linearize.rst
part_bod.rst
printing.rst
system.rst

/workspace/sympy__sympy__1.6/doc/src/modules/physics/mechanics/examples:
bicycle_example.rst
lin_pend_nonmin_example.rst
pendulum_nonmin.svg
rollingdisc.svg
rollingdisc_example.rst
rollingdisc_example_kane.rst
rollingdisc_example_kane_constraints.rst
rollingdisc_example_lagrange.rst

/workspace/sympy__sympy__1.6/doc/src/modules/physics/optics:
gaussopt.rst
index.rst
medium.rst
polarization.rst
utils.rst
waves.rst

/workspace/sympy__sympy__1.6/doc/src/modules/physics/quantum:
anticommutator.rst
cartesian.rst
cg.rst
circuitplot.rst
commutator.rst
constants.rst
dagger.rst
gate.rst
grover.rst
hilbert.rst
index.rst
innerproduct.rst
operator.rst
operatorset.rst
piab.rst
qapply.rst
qft.rst
qubit.rst
represent.rst
shor.rst
spin.rst
state.rst
tensorproduct.rst

/workspace/sympy__sympy__1.6/doc/src/modules/physics/units:
dimensions.rst
examples.rst
index.rst
philosophy.rst
prefixes.rst
quantities.rst
unitsystem.rst

/workspace/sympy__sympy__1.6/doc/src/modules/physics/vector:
advanced.rst
api
fields.rst
index.rst
kin_1.svg
kin_1pt.svg
kin_2.svg
kin_2pt.svg
kin_3.svg
kin_4.svg
kin_angvel1.svg
kin_angvel2.svg
kin_angvel3.svg
kin_rolling.svg
kinematics.rst
simp_rot.svg
vec_add.svg
vec_cross.svg
vec_dot.svg
vec_fix_notfix.svg
vec_mul.svg
vec_rep.svg
vec_simp_der.svg
vectors.rst

/workspace/sympy__sympy__1.6/doc/src/modules/physics/vector/api:
classes.rst
fieldfunctions.rst
functions.rst
kinematics.rst
printing.rst

/workspace/sympy__sympy__1.6/doc/src/modules/polys:
agca.rst
basics.rst
index.rst
internals.rst
literature.rst
reference.rst
ringseries.rst
wester.rst

/workspace/sympy__sympy__1.6/doc/src/modules/series:
formal.rst
fourier.rst
index.rst
limitseq.rst
sequences.rst
series.rst

/workspace/sympy__sympy__1.6/doc/src/modules/simplify:
hyperexpand.rst
simplify.rst

/workspace/sympy__sympy__1.6/doc/src/modules/solvers:
diophantine.rst
inequalities.rst
ode.rst
pde.rst
solvers.rst
solveset.rst

/workspace/sympy__sympy__1.6/doc/src/modules/tensor:
array.rst
index.rst
index_methods.rst
indexed.rst
tensor.rst
toperators.rst

/workspace/sympy__sympy__1.6/doc/src/modules/utilities:
autowrap.rst
codegen.rst
decorator.rst
enumerative.rst
index.rst
iterables.rst
lambdify.rst
memoization.rst
misc.rst
pkgdata.rst
pytest.rst
randtest.rst
runtests.rst
source.rst
timeutils.rst

/workspace/sympy__sympy__1.6/doc/src/modules/vector:
api
basics.rst
coordsys.rst
coordsys_rot.svg
examples.rst
fields.rst
index.rst
intro.rst

/workspace/sympy__sympy__1.6/doc/src/modules/vector/api:
classes.rst
orienterclasses.rst
vectorfunctions.rst

/workspace/sympy__sympy__1.6/doc/src/pics:
consoleascii.png
consoleunicode.png
ipythonnotebook.png
ipythonqtconsole.png
pngview1.png
winpdb1.png
winpdb2.png

/workspace/sympy__sympy__1.6/doc/src/special_topics:
finite_diff_derivatives.rst
index.rst
intro.rst

/workspace/sympy__sympy__1.6/doc/src/tutorial:
basic_operations.rst
calculus.rst
gotchas.rst
index.rst
intro.rst
manipulation.rst
matrices.rst
preliminaries.rst
printing.rst
simplification.rst
solvers.rst

/workspace/sympy__sympy__1.6/examples:
README
advanced
all.py
beginner
intermediate
notebooks

/workspace/sympy__sympy__1.6/examples/advanced:
autowrap_integrators.py
autowrap_ufuncify.py
curvilinear_coordinates.py
dense_coding_example.py
fem.py
gibbs_phenomenon.py
grover_example.py
hydrogen.py
identitysearch_example.ipynb
pidigits.py
pyglet_plotting.py
qft.py
relativity.py

/workspace/sympy__sympy__1.6/examples/beginner:
basic.py
differentiation.py
expansion.py
functions.py
limits_examples.py
plot_advanced.ipynb
plot_colors.ipynb
plot_discont.ipynb
plot_examples.py
plot_gallery.ipynb
plot_intro.ipynb
plotting_nice_plot.py
precision.py
print_pretty.py
series.py
substitution.py

/workspace/sympy__sympy__1.6/examples/intermediate:
coupled_cluster.py
differential_equations.py
infinite_1d_box.py
limit_examples_advanced.ipynb
mplot2d.py
mplot3d.py
partial_differential_eqs.py
print_gtk.py
sample.py
schwarzschild.ipynb
trees.py
vandermonde.py

/workspace/sympy__sympy__1.6/examples/notebooks:
Bezout_Dixon_resultant.ipynb
IntegrationOverPolytopes.ipynb
Macaulay_resultant.ipynb
README.txt
Sylvester_resultant.ipynb
density.ipynb
fidelity.ipynb
fresnel_integrals.ipynb
qubits.ipynb
sho1d_example.ipynb
spin.ipynb
trace.ipynb

/workspace/sympy__sympy__1.6/release:
Dockerfile
README.md
fabfile.py
pull_and_run_rever.sh
release.sh
rever.xsh

/workspace/sympy__sympy__1.6/sympy:
__init__.py
abc.py
algebras
assumptions
benchmarks
calculus
categories
codegen
combinatorics
concrete
conftest.py
core
crypto
deprecated
diffgeom
discrete
external
functions
galgebra.py
geometry
holonomic
integrals
interactive
liealgebras
logic
matrices
multipledispatch
ntheory
parsing
physics
plotting
polys
printing
release.py
sandbox
series
sets
simplify
solvers
stats
strategies
tensor
this.py
unify
utilities
vector

/workspace/sympy__sympy__1.6/sympy/algebras:
__init__.py
quaternion.py
tests

/workspace/sympy__sympy__1.6/sympy/algebras/tests:
__init__.py
test_quaternion.py

/workspace/sympy__sympy__1.6/sympy/assumptions:
__init__.py
ask.py
ask_generated.py
assume.py
cnf.py
handlers
refine.py
satask.py
sathandlers.py
tests

/workspace/sympy__sympy__1.6/sympy/assumptions/handlers:
__init__.py
calculus.py
common.py
matrices.py
ntheory.py
order.py
sets.py

/workspace/sympy__sympy__1.6/sympy/assumptions/tests:
__init__.py
test_assumptions_2.py
test_context.py
test_matrices.py
test_query.py
test_refine.py
test_satask.py
test_sathandlers.py

/workspace/sympy__sympy__1.6/sympy/benchmarks:
__init__.py
bench_discrete_log.py
bench_meijerint.py
bench_symbench.py

/workspace/sympy__sympy__1.6/sympy/calculus:
__init__.py
euler.py
finite_diff.py
singularities.py
tests
util.py

/workspace/sympy__sympy__1.6/sympy/calculus/tests:
__init__.py
test_euler.py
test_finite_diff.py
test_singularities.py
test_util.py

/workspace/sympy__sympy__1.6/sympy/categories:
__init__.py
baseclasses.py
diagram_drawing.py
tests

/workspace/sympy__sympy__1.6/sympy/categories/tests:
__init__.py
test_baseclasses.py
test_drawing.py

/workspace/sympy__sympy__1.6/sympy/codegen:
__init__.py
algorithms.py
approximations.py
array_utils.py
ast.py
cfunctions.py
cnodes.py
cutils.py
cxxnodes.py
fnodes.py
futils.py
matrix_nodes.py
pyutils.py
rewriting.py
tests

/workspace/sympy__sympy__1.6/sympy/codegen/tests:
__init__.py
test_algorithms.py
test_applications.py
test_approximations.py
test_array_utils.py
test_ast.py
test_cfunctions.py
test_cnodes.py
test_cxxnodes.py
test_fnodes.py
test_pyutils.py
test_rewriting.py

/workspace/sympy__sympy__1.6/sympy/combinatorics:
__init__.py
coset_table.py
fp_groups.py
free_groups.py
generators.py
graycode.py
group_constructs.py
homomorphisms.py
named_groups.py
partitions.py
pc_groups.py
perm_groups.py
permutations.py
polyhedron.py
prufer.py
rewritingsystem.py
rewritingsystem_fsm.py
subsets.py
tensor_can.py
tests
testutil.py
util.py

/workspace/sympy__sympy__1.6/sympy/combinatorics/tests:
__init__.py
test_coset_table.py
test_fp_groups.py
test_free_groups.py
test_generators.py
test_graycode.py
test_group_constructs.py
test_homomorphisms.py
test_named_groups.py
test_partitions.py
test_pc_groups.py
test_perm_groups.py
test_permutations.py
test_polyhedron.py
test_prufer.py
test_rewriting.py
test_subsets.py
test_tensor_can.py
test_testutil.py
test_util.py

/workspace/sympy__sympy__1.6/sympy/concrete:
__init__.py
delta.py
expr_with_intlimits.py
expr_with_limits.py
gosper.py
guess.py
products.py
summations.py
tests

/workspace/sympy__sympy__1.6/sympy/concrete/tests:
__init__.py
test_delta.py
test_gosper.py
test_guess.py
test_products.py
test_sums_products.py

/workspace/sympy__sympy__1.6/sympy/core:
__init__.py
add.py
alphabets.py
assumptions.py
backend.py
basic.py
benchmarks
cache.py
compatibility.py
containers.py
core.py
coreerrors.py
decorators.py
evalf.py
expr.py
exprtools.py
facts.py
function.py
logic.py
mod.py
mul.py
multidimensional.py
numbers.py
operations.py
parameters.py
power.py
relational.py
rules.py
singleton.py
symbol.py
sympify.py
tests
trace.py

/workspace/sympy__sympy__1.6/sympy/core/benchmarks:
__init__.py
bench_arit.py
bench_assumptions.py
bench_basic.py
bench_expand.py
bench_numbers.py
bench_sympify.py

/workspace/sympy__sympy__1.6/sympy/core/tests:
__init__.py
test_args.py
test_arit.py
test_assumptions.py
test_basic.py
test_cache.py
test_compatibility.py
test_complex.py
test_constructor_postprocessor.py
test_containers.py
test_count_ops.py
test_diff.py
test_equal.py
test_eval.py
test_evalf.py
test_expand.py
test_expr.py
test_exprtools.py
test_facts.py
test_function.py
test_logic.py
test_match.py
test_multidimensional.py
test_noncommutative.py
test_numbers.py
test_operations.py
test_parameters.py
test_power.py
test_priority.py
test_relational.py
test_rules.py
test_singleton.py
test_subs.py
test_symbol.py
test_sympify.py
test_trace.py
test_truediv.py
test_var.py

/workspace/sympy__sympy__1.6/sympy/crypto:
__init__.py
crypto.py
tests

/workspace/sympy__sympy__1.6/sympy/crypto/tests:
__init__.py
test_crypto.py

/workspace/sympy__sympy__1.6/sympy/deprecated:
__init__.py
class_registry.py
tests

/workspace/sympy__sympy__1.6/sympy/deprecated/tests:
__init__.py
test_class_registry.py

/workspace/sympy__sympy__1.6/sympy/diffgeom:
__init__.py
diffgeom.py
rn.py
tests

/workspace/sympy__sympy__1.6/sympy/diffgeom/tests:
__init__.py
test_class_structure.py
test_diffgeom.py
test_function_diffgeom_book.py
test_hyperbolic_space.py

/workspace/sympy__sympy__1.6/sympy/discrete:
__init__.py
convolutions.py
recurrences.py
tests
transforms.py

/workspace/sympy__sympy__1.6/sympy/discrete/tests:
__init__.py
test_convolutions.py
test_recurrences.py
test_transforms.py

/workspace/sympy__sympy__1.6/sympy/external:
__init__.py
importtools.py
tests

/workspace/sympy__sympy__1.6/sympy/external/tests:
__init__.py
test_autowrap.py
test_codegen.py
test_importtools.py
test_numpy.py
test_sage.py
test_scipy.py

/workspace/sympy__sympy__1.6/sympy/functions:
__init__.py
combinatorial
elementary
special

/workspace/sympy__sympy__1.6/sympy/functions/combinatorial:
__init__.py
factorials.py
numbers.py
tests

/workspace/sympy__sympy__1.6/sympy/functions/combinatorial/tests:
__init__.py
test_comb_factorials.py
test_comb_numbers.py

/workspace/sympy__sympy__1.6/sympy/functions/elementary:
__init__.py
benchmarks
complexes.py
exponential.py
hyperbolic.py
integers.py
miscellaneous.py
piecewise.py
tests
trigonometric.py

/workspace/sympy__sympy__1.6/sympy/functions/elementary/benchmarks:
__init__.py
bench_exp.py

/workspace/sympy__sympy__1.6/sympy/functions/elementary/tests:
__init__.py
test_complexes.py
test_exponential.py
test_hyperbolic.py
test_integers.py
test_interface.py
test_miscellaneous.py
test_piecewise.py
test_trigonometric.py

/workspace/sympy__sympy__1.6/sympy/functions/special:
__init__.py
benchmarks
bessel.py
beta_functions.py
bsplines.py
delta_functions.py
elliptic_integrals.py
error_functions.py
gamma_functions.py
hyper.py
mathieu_functions.py
polynomials.py
singularity_functions.py
spherical_harmonics.py
tensor_functions.py
tests
zeta_functions.py

/workspace/sympy__sympy__1.6/sympy/functions/special/benchmarks:
__init__.py
bench_special.py

/workspace/sympy__sympy__1.6/sympy/functions/special/tests:
__init__.py
test_bessel.py
test_beta_functions.py
test_bsplines.py
test_delta_functions.py
test_elliptic_integrals.py
test_error_functions.py
test_gamma_functions.py
test_hyper.py
test_mathieu.py
test_singularity_functions.py
test_spec_polynomials.py
test_spherical_harmonics.py
test_tensor_functions.py
test_zeta_functions.py

/workspace/sympy__sympy__1.6/sympy/geometry:
__init__.py
curve.py
ellipse.py
entity.py
exceptions.py
line.py
parabola.py
plane.py
point.py
polygon.py
tests
util.py

/workspace/sympy__sympy__1.6/sympy/geometry/tests:
__init__.py
test_curve.py
test_ellipse.py
test_entity.py
test_geometrysets.py
test_line.py
test_parabola.py
test_plane.py
test_point.py
test_polygon.py
test_util.py

/workspace/sympy__sympy__1.6/sympy/holonomic:
__init__.py
holonomic.py
holonomicerrors.py
linearsolver.py
numerical.py
recurrence.py
tests

/workspace/sympy__sympy__1.6/sympy/holonomic/tests:
__init__.py
test_holonomic.py
test_recurrence.py

/workspace/sympy__sympy__1.6/sympy/integrals:
__init__.py
benchmarks
deltafunctions.py
heurisch.py
integrals.py
intpoly.py
manualintegrate.py
meijerint.py
meijerint_doc.py
prde.py
quadrature.py
rationaltools.py
rde.py
risch.py
rubi
singularityfunctions.py
tests
transforms.py
trigonometry.py

/workspace/sympy__sympy__1.6/sympy/integrals/benchmarks:
__init__.py
bench_integrate.py
bench_trigintegrate.py

/workspace/sympy__sympy__1.6/sympy/integrals/rubi:
__init__.py
constraints.py
parsetools
rubi_tests
rubimain.py
rules
symbol.py
tests
utility_function.py

/workspace/sympy__sympy__1.6/sympy/integrals/rubi/parsetools:
__init__.py
generate_rules.py
generate_tests.py
header.py.txt
parse.py
tests

/workspace/sympy__sympy__1.6/sympy/integrals/rubi/parsetools/tests:
__init__.py
test_parse.py

/workspace/sympy__sympy__1.6/sympy/integrals/rubi/rubi_tests:
__init__.py
tests

/workspace/sympy__sympy__1.6/sympy/integrals/rubi/rubi_tests/tests:
__init__.py
test_1_2.py
test_1_3.py
test_1_4.py
test_exponential.py
test_hyperbolic_sine.py
test_inverse_hyperbolic_sine.py
test_inverse_sine.py
test_logarithms.py
test_miscellaneous_algebra.py
test_secant.py
test_sine.py
test_special_functions.py
test_tangent.py
test_trinomials.py

/workspace/sympy__sympy__1.6/sympy/integrals/rubi/rules:
__init__.py
binomial_products.py
exponential.py
hyperbolic.py
integrand_simplification.py
inverse_hyperbolic.py
inverse_trig.py
linear_products.py
logarithms.py
miscellaneous_algebraic.py
miscellaneous_integration.py
miscellaneous_trig.py
piecewise_linear.py
quadratic_products.py
secant.py
sine.py
special_functions.py
tangent.py
trinomial_products.py

/workspace/sympy__sympy__1.6/sympy/integrals/rubi/tests:
__init__.py
test_rubi_integrate.py
test_utility_function.py

/workspace/sympy__sympy__1.6/sympy/integrals/tests:
__init__.py
test_deltafunctions.py
test_failing_integrals.py
test_heurisch.py
test_integrals.py
test_intpoly.py
test_lineintegrals.py
test_manual.py
test_meijerint.py
test_prde.py
test_quadrature.py
test_rationaltools.py
test_rde.py
test_risch.py
test_singularityfunctions.py
test_transforms.py
test_trigonometry.py

/workspace/sympy__sympy__1.6/sympy/interactive:
__init__.py
ipythonprinting.py
printing.py
session.py
tests

/workspace/sympy__sympy__1.6/sympy/interactive/tests:
__init__.py
test_interactive.py
test_ipython.py
test_ipythonprinting.py

/workspace/sympy__sympy__1.6/sympy/liealgebras:
__init__.py
cartan_matrix.py
cartan_type.py
dynkin_diagram.py
root_system.py
tests
type_a.py
type_b.py
type_c.py
type_d.py
type_e.py
type_f.py
type_g.py
weyl_group.py

/workspace/sympy__sympy__1.6/sympy/liealgebras/tests:
__init__.py
test_cartan_matrix.py
test_cartan_type.py
test_dynkin_diagram.py
test_root_system.py
test_type_A.py
test_type_B.py
test_type_C.py
test_type_D.py
test_type_E.py
test_type_F.py
test_type_G.py
test_weyl_group.py

/workspace/sympy__sympy__1.6/sympy/logic:
__init__.py
algorithms
boolalg.py
inference.py
tests
utilities

/workspace/sympy__sympy__1.6/sympy/logic/algorithms:
__init__.py
dpll.py
dpll2.py
pycosat_wrapper.py

/workspace/sympy__sympy__1.6/sympy/logic/tests:
__init__.py
test_boolalg.py
test_dimacs.py
test_inference.py

/workspace/sympy__sympy__1.6/sympy/logic/utilities:
__init__.py
dimacs.py

/workspace/sympy__sympy__1.6/sympy/matrices:
__init__.py
benchmarks
common.py
dense.py
densearith.py
densesolve.py
densetools.py
expressions
immutable.py
matrices.py
normalforms.py
sparse.py
sparsetools.py
tests

/workspace/sympy__sympy__1.6/sympy/matrices/benchmarks:
__init__.py
bench_matrix.py

/workspace/sympy__sympy__1.6/sympy/matrices/expressions:
__init__.py
adjoint.py
applyfunc.py
blockmatrix.py
determinant.py
diagonal.py
dotproduct.py
factorizations.py
fourier.py
funcmatrix.py
hadamard.py
inverse.py
kronecker.py
matadd.py
matexpr.py
matmul.py
matpow.py
permutation.py
slice.py
tests
trace.py
transpose.py

/workspace/sympy__sympy__1.6/sympy/matrices/expressions/tests:
__init__.py
test_adjoint.py
test_applyfunc.py
test_blockmatrix.py
test_derivatives.py
test_determinant.py
test_diagonal.py
test_dotproduct.py
test_factorizations.py
test_fourier.py
test_funcmatrix.py
test_hadamard.py
test_indexing.py
test_inverse.py
test_kronecker.py
test_matadd.py
test_matexpr.py
test_matmul.py
test_matpow.py
test_permutation.py
test_slice.py
test_trace.py
test_transpose.py

/workspace/sympy__sympy__1.6/sympy/matrices/tests:
__init__.py
test_commonmatrix.py
test_densearith.py
test_densesolve.py
test_densetools.py
test_immutable.py
test_interactions.py
test_matrices.py
test_normalforms.py
test_sparse.py
test_sparsetools.py

/workspace/sympy__sympy__1.6/sympy/multipledispatch:
__init__.py
conflict.py
core.py
dispatcher.py
tests
utils.py

/workspace/sympy__sympy__1.6/sympy/multipledispatch/tests:
__init__.py
test_conflict.py
test_core.py
test_dispatcher.py

/workspace/sympy__sympy__1.6/sympy/ntheory:
__init__.py
bbp_pi.py
continued_fraction.py
egyptian_fraction.py
factor_.py
generate.py
modular.py
multinomial.py
partitions_.py
primetest.py
residue_ntheory.py
tests

/workspace/sympy__sympy__1.6/sympy/ntheory/tests:
__init__.py
test_bbp_pi.py
test_continued_fraction.py
test_egyptian_fraction.py
test_factor_.py
test_generate.py
test_modular.py
test_multinomial.py
test_partitions.py
test_primetest.py
test_residue.py

/workspace/sympy__sympy__1.6/sympy/parsing:
__init__.py
ast_parser.py
autolev
c
fortran
latex
mathematica.py
maxima.py
sym_expr.py
sympy_parser.py
tests

/workspace/sympy__sympy__1.6/sympy/parsing/autolev:
Autolev.g4
__init__.py
_antlr
_listener_autolev_antlr.py
_parse_autolev_antlr.py
test-examples

/workspace/sympy__sympy__1.6/sympy/parsing/autolev/_antlr:
__init__.py
autolevlexer.py
autolevlistener.py
autolevparser.py

/workspace/sympy__sympy__1.6/sympy/parsing/autolev/test-examples:
__init__.py
pydy-example-repo
ruletest1.al
ruletest1.py
ruletest10.al
ruletest10.py
ruletest11.al
ruletest11.py
ruletest12.al
ruletest12.py
ruletest2.al
ruletest2.py
ruletest3.al
ruletest3.py
ruletest4.al
ruletest4.py
ruletest5.al
ruletest5.py
ruletest6.al
ruletest6.py
ruletest7.al
ruletest7.py
ruletest8.al
ruletest8.py
ruletest9.al
ruletest9.py

/workspace/sympy__sympy__1.6/sympy/parsing/autolev/test-examples/pydy-example-repo:
__init__.py
chaos_pendulum.al
chaos_pendulum.py
double_pendulum.al
double_pendulum.py
mass_spring_damper.al
mass_spring_damper.py
non_min_pendulum.al
non_min_pendulum.py

/workspace/sympy__sympy__1.6/sympy/parsing/c:
__init__.py
c_parser.py

/workspace/sympy__sympy__1.6/sympy/parsing/fortran:
__init__.py
fortran_parser.py

/workspace/sympy__sympy__1.6/sympy/parsing/latex:
LICENSE.txt
LaTeX.g4
__init__.py
_antlr
_build_latex_antlr.py
_parse_latex_antlr.py
errors.py

/workspace/sympy__sympy__1.6/sympy/parsing/latex/_antlr:
__init__.py
latexlexer.py
latexparser.py

/workspace/sympy__sympy__1.6/sympy/parsing/tests:
__init__.py
test_ast_parser.py
test_autolev.py
test_c_parser.py
test_fortran_parser.py
test_implicit_multiplication_application.py
test_latex.py
test_latex_deps.py
test_mathematica.py
test_maxima.py
test_sym_expr.py
test_sympy_parser.py

/workspace/sympy__sympy__1.6/sympy/physics:
__init__.py
continuum_mechanics
gaussopt.py
hep
hydrogen.py
matrices.py
mechanics
optics
paulialgebra.py
pring.py
qho_1d.py
quantum
secondquant.py
sho.py
tests
units
vector
wigner.py

/workspace/sympy__sympy__1.6/sympy/physics/continuum_mechanics:
__init__.py
beam.py
tests

/workspace/sympy__sympy__1.6/sympy/physics/continuum_mechanics/tests:
__init__.py
test_beam.py

/workspace/sympy__sympy__1.6/sympy/physics/hep:
__init__.py
gamma_matrices.py
tests

/workspace/sympy__sympy__1.6/sympy/physics/hep/tests:
__init__.py
test_gamma_matrices.py

/workspace/sympy__sympy__1.6/sympy/physics/mechanics:
__init__.py
body.py
functions.py
kane.py
lagrange.py
linearize.py
models.py
particle.py
rigidbody.py
system.py
tests

/workspace/sympy__sympy__1.6/sympy/physics/mechanics/tests:
__init__.py
test_body.py
test_functions.py
test_kane.py
test_kane2.py
test_kane3.py
test_kane4.py
test_lagrange.py
test_lagrange2.py
test_linearize.py
test_models.py
test_particle.py
test_rigidbody.py
test_system.py

/workspace/sympy__sympy__1.6/sympy/physics/optics:
__init__.py
gaussopt.py
medium.py
polarization.py
tests
utils.py
waves.py

/workspace/sympy__sympy__1.6/sympy/physics/optics/tests:
__init__.py
test_gaussopt.py
test_medium.py
test_polarization.py
test_utils.py
test_waves.py

/workspace/sympy__sympy__1.6/sympy/physics/quantum:
__init__.py
anticommutator.py
boson.py
cartesian.py
cg.py
circuitplot.py
circuitutils.py
commutator.py
constants.py
dagger.py
density.py
fermion.py
gate.py
grover.py
hilbert.py
identitysearch.py
innerproduct.py
matrixcache.py
matrixutils.py
operator.py
operatorordering.py
operatorset.py
pauli.py
piab.py
qapply.py
qasm.py
qexpr.py
qft.py
qubit.py
represent.py
sho1d.py
shor.py
spin.py
state.py
tensorproduct.py
tests

/workspace/sympy__sympy__1.6/sympy/physics/quantum/tests:
__init__.py
test_anticommutator.py
test_boson.py
test_cartesian.py
test_cg.py
test_circuitplot.py
test_circuitutils.py
test_commutator.py
test_constants.py
test_dagger.py
test_density.py
test_fermion.py
test_gate.py
test_grover.py
test_hilbert.py
test_identitysearch.py
test_innerproduct.py
test_matrixutils.py
test_operator.py
test_operatorordering.py
test_operatorset.py
test_pauli.py
test_piab.py
test_printing.py
test_qapply.py
test_qasm.py
test_qexpr.py
test_qft.py
test_qubit.py
test_represent.py
test_sho1d.py
test_shor.py
test_spin.py
test_state.py
test_tensorproduct.py

/workspace/sympy__sympy__1.6/sympy/physics/tests:
__init__.py
test_clebsch_gordan.py
test_hydrogen.py
test_paulialgebra.py
test_physics_matrices.py
test_pring.py
test_qho_1d.py
test_secondquant.py
test_sho.py

/workspace/sympy__sympy__1.6/sympy/physics/units:
__init__.py
definitions
dimensions.py
prefixes.py
quantities.py
systems
tests
unitsystem.py
util.py

/workspace/sympy__sympy__1.6/sympy/physics/units/definitions:
__init__.py
dimension_definitions.py
unit_definitions.py

/workspace/sympy__sympy__1.6/sympy/physics/units/systems:
__init__.py
cgs.py
length_weight_time.py
mks.py
mksa.py
natural.py
si.py

/workspace/sympy__sympy__1.6/sympy/physics/units/tests:
__init__.py
test_dimensions.py
test_dimensionsystem.py
test_prefixes.py
test_quantities.py
test_unit_system_cgs_gauss.py
test_unitsystem.py
test_util.py

/workspace/sympy__sympy__1.6/sympy/physics/vector:
__init__.py
dyadic.py
fieldfunctions.py
frame.py
functions.py
point.py
printing.py
tests
vector.py

/workspace/sympy__sympy__1.6/sympy/physics/vector/tests:
__init__.py
test_dyadic.py
test_fieldfunctions.py
test_frame.py
test_functions.py
test_output.py
test_point.py
test_printing.py
test_vector.py

/workspace/sympy__sympy__1.6/sympy/plotting:
__init__.py
experimental_lambdify.py
intervalmath
plot.py
plot_implicit.py
pygletplot
tests
textplot.py

/workspace/sympy__sympy__1.6/sympy/plotting/intervalmath:
__init__.py
interval_arithmetic.py
interval_membership.py
lib_interval.py
tests

/workspace/sympy__sympy__1.6/sympy/plotting/intervalmath/tests:
__init__.py
test_interval_functions.py
test_interval_membership.py
test_intervalmath.py

/workspace/sympy__sympy__1.6/sympy/plotting/pygletplot:
__init__.py
color_scheme.py
managed_window.py
plot.py
plot_axes.py
plot_camera.py
plot_controller.py
plot_curve.py
plot_interval.py
plot_mode.py
plot_mode_base.py
plot_modes.py
plot_object.py
plot_rotation.py
plot_surface.py
plot_window.py
tests
util.py

/workspace/sympy__sympy__1.6/sympy/plotting/pygletplot/tests:
__init__.py
test_plotting.py

/workspace/sympy__sympy__1.6/sympy/plotting/tests:
__init__.py
test_experimental_lambdify.py
test_plot.py
test_plot_implicit.py
test_region_and.png
test_region_not.png
test_region_or.png
test_region_xor.png
test_textplot.py

/workspace/sympy__sympy__1.6/sympy/polys:
__init__.py
agca
benchmarks
compatibility.py
constructor.py
densearith.py
densebasic.py
densetools.py
dispersion.py
distributedmodules.py
domains
euclidtools.py
factortools.py
fglmtools.py
fields.py
galoistools.py
groebnertools.py
heuristicgcd.py
modulargcd.py
monomials.py
multivariate_resultants.py
numberfields.py
orderings.py
orthopolys.py
partfrac.py
polyclasses.py
polyconfig.py
polyerrors.py
polyfuncs.py
polymatrix.py
polyoptions.py
polyquinticconst.py
polyroots.py
polytools.py
polyutils.py
rationaltools.py
ring_series.py
rings.py
rootisolation.py
rootoftools.py
solvers.py
specialpolys.py
sqfreetools.py
subresultants_qq_zz.py
tests

/workspace/sympy__sympy__1.6/sympy/polys/agca:
__init__.py
extensions.py
homomorphisms.py
ideals.py
modules.py
tests

/workspace/sympy__sympy__1.6/sympy/polys/agca/tests:
__init__.py
test_extensions.py
test_homomorphisms.py
test_ideals.py
test_modules.py

/workspace/sympy__sympy__1.6/sympy/polys/benchmarks:
__init__.py
bench_galoispolys.py
bench_groebnertools.py
bench_solvers.py

/workspace/sympy__sympy__1.6/sympy/polys/domains:
__init__.py
algebraicfield.py
characteristiczero.py
complexfield.py
compositedomain.py
domain.py
domainelement.py
expressiondomain.py
field.py
finitefield.py
fractionfield.py
gmpyfinitefield.py
gmpyintegerring.py
gmpyrationalfield.py
groundtypes.py
integerring.py
modularinteger.py
mpelements.py
old_fractionfield.py
old_polynomialring.py
polynomialring.py
pythonfinitefield.py
pythonintegerring.py
pythonrational.py
pythonrationalfield.py
quotientring.py
rationalfield.py
realfield.py
ring.py
simpledomain.py
tests

/workspace/sympy__sympy__1.6/sympy/polys/domains/tests:
__init__.py
test_domains.py
test_polynomialring.py
test_quotientring.py

/workspace/sympy__sympy__1.6/sympy/polys/tests:
__init__.py
test_constructor.py
test_densearith.py
test_densebasic.py
test_densetools.py
test_dispersion.py
test_distributedmodules.py
test_euclidtools.py
test_factortools.py
test_fields.py
test_galoistools.py
test_groebnertools.py
test_heuristicgcd.py
test_injections.py
test_modulargcd.py
test_monomials.py
test_multivariate_resultants.py
test_numberfields.py
test_orderings.py
test_orthopolys.py
test_partfrac.py
test_polyclasses.py
test_polyfuncs.py
test_polymatrix.py
test_polyoptions.py
test_polyroots.py
test_polytools.py
test_polyutils.py
test_pythonrational.py
test_rationaltools.py
test_ring_series.py
test_rings.py
test_rootisolation.py
test_rootoftools.py
test_solvers.py
test_specialpolys.py
test_sqfreetools.py
test_subresultants_qq_zz.py

/workspace/sympy__sympy__1.6/sympy/printing:
__init__.py
ccode.py
codeprinter.py
conventions.py
cxxcode.py
defaults.py
dot.py
fcode.py
glsl.py
gtk.py
jscode.py
julia.py
lambdarepr.py
latex.py
llvmjitcode.py
maple.py
mathematica.py
mathml.py
octave.py
precedence.py
pretty
preview.py
printer.py
pycode.py
python.py
rcode.py
repr.py
rust.py
str.py
tableform.py
tensorflow.py
tests
theanocode.py
tree.py

/workspace/sympy__sympy__1.6/sympy/printing/pretty:
__init__.py
pretty.py
pretty_symbology.py
stringpict.py
tests

/workspace/sympy__sympy__1.6/sympy/printing/pretty/tests:
__init__.py
test_pretty.py

/workspace/sympy__sympy__1.6/sympy/printing/tests:
__init__.py
test_ccode.py
test_codeprinter.py
test_conventions.py
test_cxxcode.py
test_dot.py
test_fcode.py
test_glsl.py
test_gtk.py
test_jscode.py
test_julia.py
test_lambdarepr.py
test_latex.py
test_llvmjit.py
test_maple.py
test_mathematica.py
test_mathml.py
test_numpy.py
test_octave.py
test_precedence.py
test_preview.py
test_pycode.py
test_python.py
test_rcode.py
test_repr.py
test_rust.py
test_str.py
test_tableform.py
test_tensorflow.py
test_theanocode.py
test_tree.py

/workspace/sympy__sympy__1.6/sympy/sandbox:
__init__.py
indexed_integrals.py
tests

/workspace/sympy__sympy__1.6/sympy/sandbox/tests:
__init__.py
test_indexed_integrals.py

/workspace/sympy__sympy__1.6/sympy/series:
__init__.py
acceleration.py
approximants.py
aseries.py
benchmarks
formal.py
fourier.py
gruntz.py
kauers.py
limits.py
limitseq.py
order.py
residues.py
sequences.py
series.py
series_class.py
tests

/workspace/sympy__sympy__1.6/sympy/series/benchmarks:
__init__.py
bench_limit.py
bench_order.py

/workspace/sympy__sympy__1.6/sympy/series/tests:
__init__.py
test_approximants.py
test_aseries.py
test_demidovich.py
test_formal.py
test_fourier.py
test_gruntz.py
test_kauers.py
test_limits.py
test_limitseq.py
test_lseries.py
test_nseries.py
test_order.py
test_residues.py
test_sequences.py
test_series.py

/workspace/sympy__sympy__1.6/sympy/sets:
__init__.py
conditionset.py
contains.py
fancysets.py
handlers
ordinals.py
powerset.py
setexpr.py
sets.py
tests

/workspace/sympy__sympy__1.6/sympy/sets/handlers:
__init__.py
add.py
functions.py
intersection.py
issubset.py
mul.py
power.py
union.py

/workspace/sympy__sympy__1.6/sympy/sets/tests:
__init__.py
test_conditionset.py
test_contains.py
test_fancysets.py
test_ordinals.py
test_powerset.py
test_setexpr.py
test_sets.py

/workspace/sympy__sympy__1.6/sympy/simplify:
__init__.py
combsimp.py
cse_main.py
cse_opts.py
epathtools.py
fu.py
gammasimp.py
hyperexpand.py
hyperexpand_doc.py
powsimp.py
radsimp.py
ratsimp.py
simplify.py
sqrtdenest.py
tests
traversaltools.py
trigsimp.py

/workspace/sympy__sympy__1.6/sympy/simplify/tests:
__init__.py
test_combsimp.py
test_cse.py
test_epathtools.py
test_fu.py
test_function.py
test_gammasimp.py
test_hyperexpand.py
test_powsimp.py
test_radsimp.py
test_ratsimp.py
test_rewrite.py
test_simplify.py
test_sqrtdenest.py
test_traversaltools.py
test_trigsimp.py

/workspace/sympy__sympy__1.6/sympy/solvers:
__init__.py
benchmarks
bivariate.py
decompogen.py
deutils.py
diophantine.py
inequalities.py
ode.py
pde.py
polysys.py
recurr.py
solvers.py
solveset.py
tests

/workspace/sympy__sympy__1.6/sympy/solvers/benchmarks:
__init__.py
bench_solvers.py

/workspace/sympy__sympy__1.6/sympy/solvers/tests:
__init__.py
test_constantsimp.py
test_decompogen.py
test_diophantine.py
test_inequalities.py
test_numeric.py
test_ode.py
test_pde.py
test_polysys.py
test_recurr.py
test_solvers.py
test_solveset.py

/workspace/sympy__sympy__1.6/sympy/stats:
__init__.py
crv.py
crv_types.py
drv.py
drv_types.py
error_prop.py
frv.py
frv_types.py
joint_rv.py
joint_rv_types.py
random_matrix.py
random_matrix_models.py
rv.py
rv_interface.py
stochastic_process.py
stochastic_process_types.py
symbolic_probability.py
tests

/workspace/sympy__sympy__1.6/sympy/stats/tests:
__init__.py
test_continuous_rv.py
test_discrete_rv.py
test_error_prop.py
test_finite_rv.py
test_joint_rv.py
test_mix.py
test_random_matrix.py
test_rv.py
test_stochastic_process.py
test_symbolic_probability.py

/workspace/sympy__sympy__1.6/sympy/strategies:
__init__.py
branch
core.py
rl.py
tests
tools.py
traverse.py
tree.py
util.py

/workspace/sympy__sympy__1.6/sympy/strategies/branch:
__init__.py
core.py
tests
tools.py
traverse.py

/workspace/sympy__sympy__1.6/sympy/strategies/branch/tests:
__init__.py
test_core.py
test_tools.py
test_traverse.py

/workspace/sympy__sympy__1.6/sympy/strategies/tests:
__init__.py
test_core.py
test_rl.py
test_strat.py
test_tools.py
test_traverse.py
test_tree.py

/workspace/sympy__sympy__1.6/sympy/tensor:
__init__.py
array
functions.py
index_methods.py
indexed.py
tensor.py
tests
toperators.py

/workspace/sympy__sympy__1.6/sympy/tensor/array:
__init__.py
array_comprehension.py
arrayop.py
dense_ndim_array.py
mutable_ndim_array.py
ndim_array.py
sparse_ndim_array.py
tests

/workspace/sympy__sympy__1.6/sympy/tensor/array/tests:
__init__.py
test_array_comprehension.py
test_arrayop.py
test_immutable_ndim_array.py
test_mutable_ndim_array.py
test_ndim_array.py
test_ndim_array_conversions.py

/workspace/sympy__sympy__1.6/sympy/tensor/tests:
__init__.py
test_functions.py
test_index_methods.py
test_indexed.py
test_tensor.py
test_tensor_element.py
test_tensor_operators.py

/workspace/sympy__sympy__1.6/sympy/unify:
__init__.py
core.py
rewrite.py
tests
usympy.py

/workspace/sympy__sympy__1.6/sympy/unify/tests:
__init__.py
test_rewrite.py
test_sympy.py
test_unify.py

/workspace/sympy__sympy__1.6/sympy/utilities:
__init__.py
_compilation
autowrap.py
benchmarking.py
codegen.py
decorator.py
enumerative.py
exceptions.py
iterables.py
lambdify.py
magic.py
matchpy_connector.py
mathml
memoization.py
misc.py
pkgdata.py
pytest.py
quality_unicode.py
randtest.py
runtests.py
source.py
tests
timeutils.py
tmpfiles.py

/workspace/sympy__sympy__1.6/sympy/utilities/_compilation:
__init__.py
availability.py
compilation.py
runners.py
tests
util.py

/workspace/sympy__sympy__1.6/sympy/utilities/_compilation/tests:
__init__.py
test_compilation.py

/workspace/sympy__sympy__1.6/sympy/utilities/mathml:
__init__.py
data

/workspace/sympy__sympy__1.6/sympy/utilities/mathml/data:
mmlctop.xsl
mmltex.xsl
simple_mmlctop.xsl

/workspace/sympy__sympy__1.6/sympy/utilities/tests:
__init__.py
diagnose_imports.py
test_autowrap.py
test_code_quality.py
test_codegen.py
test_codegen_julia.py
test_codegen_octave.py
test_codegen_rust.py
test_decorator.py
test_enumerative.py
test_iterables.py
test_lambdify.py
test_misc.py
test_module_imports.py
test_pickling.py
test_pytest.py
test_source.py
test_timeutils.py
test_wester.py

/workspace/sympy__sympy__1.6/sympy/vector:
__init__.py
basisdependent.py
coordsysrect.py
deloperator.py
dyadic.py
functions.py
operators.py
orienters.py
point.py
scalar.py
tests
vector.py

/workspace/sympy__sympy__1.6/sympy/vector/tests:
__init__.py
test_coordsysrect.py
test_dyadic.py
test_field_functions.py
test_functions.py
test_operators.py
test_printing.py
test_vector.py

/workspace/sympy__sympy__1.6/sympy.egg-info:
PKG-INFO
SOURCES.txt
dependency_links.txt
entry_points.txt
not-zip-safe
requires.txt
top_level.txt

[Select the relevant files and use repo map to get highlevel representation and structure of repo]


============================================================



ACTION:

THOUGHT: Based on the PR description, we need to fix the `nthroot_mod` function which is missing one root (x = 0) when a ≡ 0 (mod p). This would likely be in the number theory module.

Let me first create a script to reproduce the issue:
CODE:
CODE = """
from sympy.ntheory import nthroot_mod

# Test case from PR description
result = nthroot_mod(17*17, 5, 17)
print(f"Current roots for x^5 ≡ {17*17} (mod 17): {result}")
"""
create_file("reproduce.py", CODE)

============================================================



OBSERVATION:

[File reproduce.py created.]


============================================================



ACTION:

THOUGHT: Let's run the script to confirm the issue:
COMMAND:
python3 reproduce.py

============================================================



OBSERVATION:

Current roots for x^5 ≡ 289 (mod 17): 0


============================================================



ACTION:

THOUGHT: Interesting - I notice that the function is actually returning 0 as a root. Let me modify the test case to better demonstrate the issue mentioned in the PR:
CODE:
CODE = """
from sympy.ntheory import nthroot_mod

# Test with a case where a ≡ 0 (mod p)
result = nthroot_mod(17, 2, 17)  # Testing x^2 ≡ 17 (mod 17) ≡ 0 (mod 17)
print(f"Current roots for x^2 ≡ 17 ≡ 0 (mod 17): {result}")
"""
create_file("reproduce.py", CODE)

============================================================



OBSERVATION:

[File reproduce.py already exists and File overwritten.]
[File: /workspace/reproduce.py (6 lines total after edit)]
1|
2|from sympy.ntheory import nthroot_mod
3|
4|# Test with a case where a ≡ 0 (mod p)
5|result = nthroot_mod(17, 2, 17)  # Testing x^2 ≡ 17 (mod 17) ≡ 0 (mod 17)
6|print(f"Current roots for x^2 ≡ 17 ≡ 0 (mod 17): {result}")
[File updated. Please review the changes carefully and make sure they are correct (correct indentation, no duplicate or redundant lines etc). Edit the file again if necessary.]


============================================================



ACTION:

THOUGHT: Let's run the modified script:
COMMAND:
python3 reproduce.py

============================================================



OBSERVATION:

Current roots for x^2 ≡ 17 ≡ 0 (mod 17): 0


============================================================



ACTION:

THOUGHT: Let me try one more test case to better understand the issue:
CODE:
CODE = """
from sympy.ntheory import nthroot_mod

# Test case where a is explicitly 0 mod p
result = nthroot_mod(0, 2, 17)  # Testing x^2 ≡ 0 (mod 17)
print(f"Current roots for x^2 ≡ 0 (mod 17): {result}")
"""
create_file("reproduce.py", CODE)

============================================================



OBSERVATION:

[File reproduce.py already exists and File overwritten.]
[File: /workspace/reproduce.py (6 lines total after edit)]
1|
2|from sympy.ntheory import nthroot_mod
3|
4|# Test case where a is explicitly 0 mod p
5|result = nthroot_mod(0, 2, 17)  # Testing x^2 ≡ 0 (mod 17)
6|print(f"Current roots for x^2 ≡ 0 (mod 17): {result}")
[File updated. Please review the changes carefully and make sure they are correct (correct indentation, no duplicate or redundant lines etc). Edit the file again if necessary.]


============================================================



ACTION:

THOUGHT: Let's run this test case:
COMMAND:
python3 reproduce.py

============================================================



OBSERVATION:

Current roots for x^2 ≡ 0 (mod 17): 0


============================================================



ACTION:

THOUGHT: Let me check the implementation of `nthroot_mod` function to understand how it handles the case when a ≡ 0 (mod p):
CODE:
open_file('/workspace/sympy__sympy__1.6/sympy/ntheory/residue_ntheory.py')

============================================================



OBSERVATION:

[File: /workspace/sympy__sympy__1.6/sympy/ntheory/residue_ntheory.py (1302 lines total)]
1|from __future__ import print_function, division
2|
3|from sympy.core.compatibility import as_int, range
4|from sympy.core.function import Function
5|from sympy.core.numbers import igcd, igcdex, mod_inverse
6|from sympy.core.power import isqrt
7|from sympy.core.singleton import S
8|from .primetest import isprime
9|from .factor_ import factorint, trailing, totient, multiplicity
10|from random import randint, Random
11|
12|
13|
14|def n_order(a, n):
15|    """Returns the order of ``a`` modulo ``n``.
16|
17|    The order of ``a`` modulo ``n`` is the smallest integer
18|    ``k`` such that ``a**k`` leaves a remainder of 1 with ``n``.
19|
20|    Examples
21|    ========
22|
23|    >>> from sympy.ntheory import n_order
24|    >>> n_order(3, 7)
25|    6
26|    >>> n_order(4, 7)
27|    3
28|    """
29|    from collections import defaultdict
30|    a, n = as_int(a), as_int(n)
31|    if igcd(a, n) != 1:
32|        raise ValueError("The two numbers should be relatively prime")
33|    factors = defaultdict(int)
34|    f = factorint(n)
35|    for px, kx in f.items():
36|        if kx > 1:
37|            factors[px] += kx - 1
38|        fpx = factorint(px - 1)
39|        for py, ky in fpx.items():
40|            factors[py] += ky
41|    group_order = 1
42|    for px, kx in factors.items():
43|        group_order *= px**kx
44|    order = 1
45|    if a > n:
46|        a = a % n
47|    for p, e in factors.items():
48|        exponent = group_order
49|        for f in range(e + 1):
50|            if pow(a, exponent, n) != 1:
51|                order *= p ** (e - f + 1)
52|                break
53|            exponent = exponent // p
54|    return order
55|
56|
57|def _primitive_root_prime_iter(p):
58|    """
59|    Generates the primitive roots for a prime ``p``
60|
61|    Examples
62|    ========
63|
64|    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_iter
65|    >>> list(_primitive_root_prime_iter(19))
66|    [2, 3, 10, 13, 14, 15]
67|
68|    References
69|    ==========
70|
71|    .. [1] W. Stein "Elementary Number Theory" (2011), page 44
72|
73|    """
74|    # it is assumed that p is an int
75|    v = [(p - 1) // i for i in factorint(p - 1).keys()]
76|    a = 2
77|    while a < p:
78|        for pw in v:
79|            # a TypeError below may indicate that p was not an int
80|            if pow(a, pw, p) == 1:
81|                break
82|        else:
83|            yield a
84|        a += 1
85|
86|
87|def primitive_root(p):
88|    """
89|    Returns the smallest primitive root or None
90|
91|    Parameters
92|    ==========
93|
94|    p : positive integer
95|
96|    Examples
97|    ========
98|
99|    >>> from sympy.ntheory.residue_ntheory import primitive_root
100|    >>> primitive_root(19)
101|    2
102|
103|    References
104|    ==========
105|
106|    .. [1] W. Stein "Elementary Number Theory" (2011), page 44
107|    .. [2] P. Hackman "Elementary Number Theory" (2009), Chapter C
108|
109|    """
110|    p = as_int(p)
111|    if p < 1:
112|        raise ValueError('p is required to be positive')
113|    if p <= 2:
114|        return 1
115|    f = factorint(p)
116|    if len(f) > 2:
117|        return None
118|    if len(f) == 2:
119|        if 2 not in f or f[2] > 1:
120|            return None
121|
122|        # case p = 2*p1**k, p1 prime
123|        for p1, e1 in f.items():
124|            if p1 != 2:
125|                break
126|        i = 1
127|        while i < p:
128|            i += 2
129|            if i % p1 == 0:
130|                continue
131|            if is_primitive_root(i, p):
132|                return i
133|
134|    else:
135|        if 2 in f:
136|            if p == 4:
137|                return 3
138|            return None
139|        p1, n = list(f.items())[0]
140|        if n > 1:
141|            # see Ref [2], page 81
142|            g = primitive_root(p1)
143|            if is_primitive_root(g, p1**2):
144|                return g
145|            else:
146|                for i in range(2, g + p1 + 1):
147|                    if igcd(i, p) == 1 and is_primitive_root(i, p):
148|                        return i
149|
150|    return next(_primitive_root_prime_iter(p))
151|
152|
153|def is_primitive_root(a, p):
154|    """
155|    Returns True if ``a`` is a primitive root of ``p``
156|
157|    ``a`` is said to be the primitive root of ``p`` if gcd(a, p) == 1 and
158|    totient(p) is the smallest positive number s.t.
159|
160|        a**totient(p) cong 1 mod(p)
161|
162|    Examples
163|    ========
164|
165|    >>> from sympy.ntheory import is_primitive_root, n_order, totient
166|    >>> is_primitive_root(3, 10)
167|    True
168|    >>> is_primitive_root(9, 10)
169|    False
170|    >>> n_order(3, 10) == totient(10)
171|    True
172|    >>> n_order(9, 10) == totient(10)
173|    False
174|
175|    """
176|    a, p = as_int(a), as_int(p)
177|    if igcd(a, p) != 1:
178|        raise ValueError("The two numbers should be relatively prime")
179|    if a > p:
180|        a = a % p
181|    return n_order(a, p) == totient(p)
182|
183|
184|def _sqrt_mod_tonelli_shanks(a, p):
185|    """
186|    Returns the square root in the case of ``p`` prime with ``p == 1 (mod 8)``
187|
188|    References
189|    ==========
190|
191|    .. [1] R. Crandall and C. Pomerance "Prime Numbers", 2nt Ed., page 101
192|
193|    """
194|    s = trailing(p - 1)
195|    t = p >> s
196|    # find a non-quadratic residue
197|    while 1:
198|        d = randint(2, p - 1)
199|        r = legendre_symbol(d, p)
200|        if r == -1:
201|            break
202|    #assert legendre_symbol(d, p) == -1
203|    A = pow(a, t, p)
204|    D = pow(d, t, p)
205|    m = 0
206|    for i in range(s):
207|        adm = A*pow(D, m, p) % p
208|        adm = pow(adm, 2**(s - 1 - i), p)
209|        if adm % p == p - 1:
210|            m += 2**i
211|    #assert A*pow(D, m, p) % p == 1
212|    x = pow(a, (t + 1)//2, p)*pow(D, m//2, p) % p
213|    return x
214|
215|
216|def sqrt_mod(a, p, all_roots=False):
217|    """
218|    Find a root of ``x**2 = a mod p``
219|
220|    Parameters
221|    ==========
222|
223|    a : integer
224|    p : positive integer
225|    all_roots : if True the list of roots is returned or None
226|
227|    Notes
228|    =====
229|
230|    If there is no root it is returned None; else the returned root
231|    is less or equal to ``p // 2``; in general is not the smallest one.
232|    It is returned ``p // 2`` only if it is the only root.
233|
234|    Use ``all_roots`` only when it is expected that all the roots fit
235|    in memory; otherwise use ``sqrt_mod_iter``.
236|
237|    Examples
238|    ========
239|
240|    >>> from sympy.ntheory import sqrt_mod
241|    >>> sqrt_mod(11, 43)
242|    21
243|    >>> sqrt_mod(17, 32, True)
244|    [7, 9, 23, 25]
245|    """
246|    if all_roots:
247|        return sorted(list(sqrt_mod_iter(a, p)))
248|    try:
249|        p = abs(as_int(p))
250|        it = sqrt_mod_iter(a, p)
251|        r = next(it)
252|        if r > p // 2:
253|            return p - r
254|        elif r < p // 2:
255|            return r
256|        else:
257|            try:
258|                r = next(it)
259|                if r > p // 2:
260|                    return p - r
261|            except StopIteration:
262|                pass
263|            return r
264|    except StopIteration:
265|        return None
266|
267|
268|def _product(*iters):
269|    """
270|    Cartesian product generator
271|
272|    Notes
273|    =====
274|
275|    Unlike itertools.product, it works also with iterables which do not fit
276|    in memory. See http://bugs.python.org/issue10109
277|
278|    Author: Fernando Sumudu
279|    with small changes
280|    """
281|    import itertools
282|    inf_iters = tuple(itertools.cycle(enumerate(it)) for it in iters)
283|    num_iters = len(inf_iters)
284|    cur_val = [None]*num_iters
285|
286|    first_v = True
287|    while True:
288|        i, p = 0, num_iters
289|        while p and not i:
290|            p -= 1
291|            i, cur_val[p] = next(inf_iters[p])
292|
293|        if not p and not i:
294|            if first_v:
295|                first_v = False
296|            else:
297|                break
298|
299|        yield cur_val
300|
301|
302|def sqrt_mod_iter(a, p, domain=int):
303|    """
304|    Iterate over solutions to ``x**2 = a mod p``
305|
306|    Parameters
307|    ==========
308|
309|    a : integer
310|    p : positive integer
311|    domain : integer domain, ``int``, ``ZZ`` or ``Integer``
312|
313|    Examples
314|    ========
315|
316|    >>> from sympy.ntheory.residue_ntheory import sqrt_mod_iter
317|    >>> list(sqrt_mod_iter(11, 43))
318|    [21, 22]
319|    """
320|    from sympy.polys.galoistools import gf_crt1, gf_crt2
321|    from sympy.polys.domains import ZZ
322|    a, p = as_int(a), abs(as_int(p))
323|    if isprime(p):
324|        a = a % p
325|        if a == 0:
326|            res = _sqrt_mod1(a, p, 1)
327|        else:
328|            res = _sqrt_mod_prime_power(a, p, 1)
329|        if res:
330|            if domain is ZZ:
331|                for x in res:
332|                    yield x
333|            else:
334|                for x in res:
335|                    yield domain(x)
336|    else:
337|        f = factorint(p)
338|        v = []
339|        pv = []
340|        for px, ex in f.items():
341|            if a % px == 0:
342|                rx = _sqrt_mod1(a, px, ex)
343|                if not rx:
344|                    return
345|            else:
346|                rx = _sqrt_mod_prime_power(a, px, ex)
347|                if not rx:
348|                    return
349|            v.append(rx)
350|            pv.append(px**ex)
351|        mm, e, s = gf_crt1(pv, ZZ)
352|        if domain is ZZ:
353|            for vx in _product(*v):
354|                r = gf_crt2(vx, pv, mm, e, s, ZZ)
355|                yield r
356|        else:
357|            for vx in _product(*v):
358|                r = gf_crt2(vx, pv, mm, e, s, ZZ)
359|                yield domain(r)
360|
361|
362|def _sqrt_mod_prime_power(a, p, k):
363|    """
364|    Find the solutions to ``x**2 = a mod p**k`` when ``a % p != 0``
365|
366|    Parameters
367|    ==========
368|
369|    a : integer
370|    p : prime number
371|    k : positive integer
372|
373|    Examples
374|    ========
375|
376|    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_prime_power
377|    >>> _sqrt_mod_prime_power(11, 43, 1)
378|    [21, 22]
379|
380|    References
381|    ==========
382|
383|    .. [1] P. Hackman "Elementary Number Theory" (2009), page 160
384|    .. [2] http://www.numbertheory.org/php/squareroot.html
385|    .. [3] [Gathen99]_
386|    """
387|    from sympy.core.numbers import igcdex
388|    from sympy.polys.domains import ZZ
389|
390|    pk = p**k
391|    a = a % pk
392|
393|    if k == 1:
394|        if p == 2:
395|            return [ZZ(a)]
396|        if not (a % p < 2 or pow(a, (p - 1) // 2, p) == 1):
397|            return None
398|
399|        if p % 4 == 3:
400|            res = pow(a, (p + 1) // 4, p)
401|        elif p % 8 == 5:
402|            sign = pow(a, (p - 1) // 4, p)
403|            if sign == 1:
404|                res = pow(a, (p + 3) // 8, p)
405|            else:
406|                b = pow(4*a, (p - 5) // 8, p)
407|                x =  (2*a*b) % p
408|                if pow(x, 2, p) == a:
409|                    res = x
410|        else:
411|            res = _sqrt_mod_tonelli_shanks(a, p)
412|
413|        # ``_sqrt_mod_tonelli_shanks(a, p)`` is not deterministic;
414|        # sort to get always the same result
415|        return sorted([ZZ(res), ZZ(p - res)])
416|
417|    if k > 1:
418|        # see Ref.[2]
419|        if p == 2:
420|            if a % 8 != 1:
421|                return None
422|            if k <= 3:
423|               s = set()
424|               for i in range(0, pk, 4):
425|                    s.add(1 + i)
426|                    s.add(-1 + i)
427|               return list(s)
428|            # according to Ref.[2] for k > 2 there are two solutions
429|            # (mod 2**k-1), that is four solutions (mod 2**k), which can be
430|            # obtained from the roots of x**2 = 0 (mod 8)
431|            rv = [ZZ(1), ZZ(3), ZZ(5), ZZ(7)]
432|            # hensel lift them to solutions of x**2 = 0 (mod 2**k)
433|            # if r**2 - a = 0 mod 2**nx but not mod 2**(nx+1)
434|            # then r + 2**(nx - 1) is a root mod 2**(nx+1)
435|            n = 3
436|            res = []
437|            for r in rv:
438|                nx = n
439|                while nx < k:
440|                    r1 = (r**2 - a) >> nx
441|                    if r1 % 2:
442|                        r = r + (1 << (nx - 1))
443|                    #assert (r**2 - a)% (1 << (nx + 1)) == 0
444|                    nx += 1
445|                if r not in res:
446|                    res.append(r)
447|                x = r + (1 << (k - 1))
448|                #assert (x**2 - a) % pk == 0
449|                if x < (1 << nx) and x not in res:
450|                    if (x**2 - a) % pk == 0:
451|                        res.append(x)
452|            return res
453|        rv = _sqrt_mod_prime_power(a, p, 1)
454|        if not rv:
455|            return None
456|        r = rv[0]
457|        fr = r**2 - a
458|        # hensel lifting with Newton iteration, see Ref.[3] chapter 9
459|        # with f(x) = x**2 - a; one has f'(a) != 0 (mod p) for p != 2
460|        n = 1
461|        px = p
462|        while 1:
463|            n1 = n
464|            n1 *= 2
465|            if n1 > k:
466|                break
467|            n = n1
468|            px = px**2
469|            frinv = igcdex(2*r, px)[0]
470|            r = (r - fr*frinv) % px
471|            fr = r**2 - a
472|        if n < k:
473|            px = p**k
474|            frinv = igcdex(2*r, px)[0]
475|            r = (r - fr*frinv) % px
476|        return [r, px - r]
477|
478|
479|def _sqrt_mod1(a, p, n):
480|    """
481|    Find solution to ``x**2 == a mod p**n`` when ``a % p == 0``
482|
483|    see http://www.numbertheory.org/php/squareroot.html
484|    """
485|    pn = p**n
486|    a = a % pn
487|    if a == 0:
488|        # case gcd(a, p**k) = p**n
489|        m = n // 2
490|        if n % 2 == 1:
491|            pm1 = p**(m + 1)
492|            def _iter0a():
493|                i = 0
494|                while i < pn:
495|                    yield i
496|                    i += pm1
497|            return _iter0a()
498|        else:
499|            pm = p**m
500|            def _iter0b():
501|                i = 0
502|                while i < pn:
503|                    yield i
504|                    i += pm
505|            return _iter0b()
506|
507|    # case gcd(a, p**k) = p**r, r < n
508|    f = factorint(a)
509|    r = f[p]
510|    if r % 2 == 1:
511|        return None
512|    m = r // 2
513|    a1 = a >> r
514|    if p == 2:
515|        if n - r == 1:
516|            pnm1 = 1 << (n - m + 1)
517|            pm1 = 1 << (m + 1)
518|            def _iter1():
519|                k = 1 << (m + 2)
520|                i = 1 << m
521|                while i < pnm1:
522|                    j = i
523|                    while j < pn:
524|                        yield j
525|                        j += k
526|                    i += pm1
527|            return _iter1()
528|        if n - r == 2:
529|            res = _sqrt_mod_prime_power(a1, p, n - r)
530|            if res is None:
531|                return None
532|            pnm = 1 << (n - m)
533|            def _iter2():
534|                s = set()
535|                for r in res:
536|                    i = 0
537|                    while i < pn:
538|                        x = (r << m) + i
539|                        if x not in s:
540|                            s.add(x)
541|                            yield x
542|                        i += pnm
543|            return _iter2()
544|        if n - r > 2:
545|            res = _sqrt_mod_prime_power(a1, p, n - r)
546|            if res is None:
547|                return None
548|            pnm1 = 1 << (n - m - 1)
549|            def _iter3():
550|                s = set()
551|                for r in res:
552|                    i = 0
553|                    while i < pn:
554|                        x = ((r << m) + i) % pn
555|                        if x not in s:
556|                            s.add(x)
557|                            yield x
558|                        i += pnm1
559|            return _iter3()
560|    else:
561|        m = r // 2
562|        a1 = a // p**r
563|        res1 = _sqrt_mod_prime_power(a1, p, n - r)
564|        if res1 is None:
565|            return None
566|        pm = p**m
567|        pnr = p**(n-r)
568|        pnm = p**(n-m)
569|
570|        def _iter4():
571|            s = set()
572|            pm = p**m
573|            for rx in res1:
574|                i = 0
575|                while i < pnm:
576|                    x = ((rx + i) % pn)
577|                    if x not in s:
578|                        s.add(x)
579|                        yield x*pm
580|                    i += pnr
581|        return _iter4()
582|
583|
584|def is_quad_residue(a, p):
585|    """
586|    Returns True if ``a`` (mod ``p``) is in the set of squares mod ``p``,
587|    i.e a % p in set([i**2 % p for i in range(p)]). If ``p`` is an odd
588|    prime, an iterative method is used to make the determination:
589|
590|    >>> from sympy.ntheory import is_quad_residue
591|    >>> sorted(set([i**2 % 7 for i in range(7)]))
592|    [0, 1, 2, 4]
593|    >>> [j for j in range(7) if is_quad_residue(j, 7)]
594|    [0, 1, 2, 4]
595|
596|    See Also
597|    ========
598|
599|    legendre_symbol, jacobi_symbol
600|    """
601|    a, p = as_int(a), as_int(p)
602|    if p < 1:
603|        raise ValueError('p must be > 0')
604|    if a >= p or a < 0:
605|        a = a % p
606|    if a < 2 or p < 3:
607|        return True
608|    if not isprime(p):
609|        if p % 2 and jacobi_symbol(a, p) == -1:
610|            return False
611|        r = sqrt_mod(a, p)
612|        if r is None:
613|            return False
614|        else:
615|            return True
616|
617|    return pow(a, (p - 1) // 2, p) == 1
618|
619|
620|def is_nthpow_residue(a, n, m):
621|    """
622|    Returns True if ``x**n == a (mod m)`` has solutions.
623|
624|    References
625|    ==========
626|
627|    .. [1] P. Hackman "Elementary Number Theory" (2009), page 76
628|
629|    """
630|    a, n, m = as_int(a), as_int(n), as_int(m)
631|    if m <= 0:
632|        raise ValueError('m must be > 0')
633|    if n < 0:
634|        raise ValueError('n must be >= 0')
635|    if a < 0:
636|        raise ValueError('a must be >= 0')
637|    if n == 0:
638|        if m == 1:
639|            return False
640|        return a == 1
641|    if a % m == 0:
642|        return True
643|    if n == 1:
644|        return True
645|    if n == 2:
646|        return is_quad_residue(a, m)
647|    return _is_nthpow_residue_bign(a, n, m)
648|
649|
650|def _is_nthpow_residue_bign(a, n, m):
651|    """Returns True if ``x**n == a (mod m)`` has solutions for n > 2."""
652|    # assert n > 2
653|    # assert a > 0 and m > 0
654|    if primitive_root(m) is None:
655|        # assert m >= 8
656|        for prime, power in factorint(m).items():
657|            if not _is_nthpow_residue_bign_prime_power(a, n, prime, power):
658|                return False
659|        return True
660|    f = totient(m)
661|    k = f // igcd(f, n)
662|    return pow(a, k, m) == 1
663|
664|
665|def _is_nthpow_residue_bign_prime_power(a, n, p, k):
666|    """Returns True/False if a solution for ``x**n == a (mod(p**k))``
667|    does/doesn't exist."""
668|    # assert a > 0
669|    # assert n > 2
670|    # assert p is prime
671|    # assert k > 0
672|    if a % p:
673|        if p != 2:
674|            return _is_nthpow_residue_bign(a, n, pow(p, k))
675|        if n & 1:
676|            return True
677|        c = trailing(n)
678|        return a % pow(2, min(c + 2, k)) == 1
679|    else:
680|        a %= pow(p, k)
681|        if not a:
682|            return True
683|        mu = multiplicity(p, a)
684|        if mu % n:
685|            return False
686|        pm = pow(p, mu)
687|        return _is_nthpow_residue_bign_prime_power(a//pm, n, p, k - mu)
688|
689|
690|def _nthroot_mod2(s, q, p):
691|    f = factorint(q)
692|    v = []
693|    for b, e in f.items():
694|        v.extend([b]*e)
695|    for qx in v:
696|        s = _nthroot_mod1(s, qx, p, False)
697|    return s
698|
699|
700|def _nthroot_mod1(s, q, p, all_roots):
701|    """
702|    Root of ``x**q = s mod p``, ``p`` prime and ``q`` divides ``p - 1``
703|
704|    References
705|    ==========
706|
707|    .. [1] A. M. Johnston "A Generalized qth Root Algorithm"
708|
709|    """
710|    g = primitive_root(p)
711|    if not isprime(q):
712|        r = _nthroot_mod2(s, q, p)
713|    else:
714|        f = p - 1
715|        assert (p - 1) % q == 0
716|        # determine k
717|        k = 0
718|        while f % q == 0:
719|            k += 1
720|            f = f // q
721|        # find z, x, r1
722|        f1 = igcdex(-f, q)[0] % q
723|        z = f*f1
724|        x = (1 + z) // q
725|        r1 = pow(s, x, p)
726|        s1 = pow(s, f, p)
727|        h = pow(g, f*q, p)
728|        t = discrete_log(p, s1, h)
729|        g2 = pow(g, z*t, p)
730|        g3 = igcdex(g2, p)[0]
731|        r = r1*g3 % p
732|        #assert pow(r, q, p) == s
733|    res = [r]
734|    h = pow(g, (p - 1) // q, p)
735|    #assert pow(h, q, p) == 1
736|    hx = r
737|    for i in range(q - 1):
738|        hx = (hx*h) % p
739|        res.append(hx)
740|    if all_roots:
741|        res.sort()
742|        return res
743|    return min(res)
744|
745|
746|def nthroot_mod(a, n, p, all_roots=False):
747|    """
748|    Find the solutions to ``x**n = a mod p``
749|
750|    Parameters
751|    ==========
752|
753|    a : integer
754|    n : positive integer
755|    p : positive integer
756|    all_roots : if False returns the smallest root, else the list of roots
757|
758|    Examples
759|    ========
760|
761|    >>> from sympy.ntheory.residue_ntheory import nthroot_mod
762|    >>> nthroot_mod(11, 4, 19)
763|    8
764|    >>> nthroot_mod(11, 4, 19, True)
765|    [8, 11]
766|    >>> nthroot_mod(68, 3, 109)
767|    23
768|    """
769|    from sympy.core.numbers import igcdex
770|    a, n, p = as_int(a), as_int(n), as_int(p)
771|    if n == 2:
772|        return sqrt_mod(a, p, all_roots)
773|    # see Hackman "Elementary Number Theory" (2009), page 76
774|    if not is_nthpow_residue(a, n, p):
775|        return None
776|    if not isprime(p):
777|        raise NotImplementedError("Not implemented for composite p")
778|
779|    if (p - 1) % n == 0:
780|        return _nthroot_mod1(a, n, p, all_roots)
781|    # The roots of ``x**n - a = 0 (mod p)`` are roots of
782|    # ``gcd(x**n - a, x**(p - 1) - 1) = 0 (mod p)``
783|    pa = n
784|    pb = p - 1
785|    b = 1
786|    if pa < pb:
787|        a, pa, b, pb = b, pb, a, pa
788|    while pb:
789|        # x**pa - a = 0; x**pb - b = 0
790|        # x**pa - a = x**(q*pb + r) - a = (x**pb)**q * x**r - a =
791|        #             b**q * x**r - a; x**r - c = 0; c = b**-q * a mod p
792|        q, r = divmod(pa, pb)
793|        c = pow(b, q, p)
794|        c = igcdex(c, p)[0]
795|        c = (c * a) % p
796|        pa, pb = pb, r
797|        a, b = b, c
798|    if pa == 1:
799|        if all_roots:
800|            res = [a]
801|        else:
802|            res = a
803|    elif pa == 2:
804|        return sqrt_mod(a, p , all_roots)
805|    else:
806|        res = _nthroot_mod1(a, pa, p, all_roots)
807|    return res
808|
809|
810|def quadratic_residues(p):
811|    """
812|    Returns the list of quadratic residues.
813|
814|    Examples
815|    ========
816|
817|    >>> from sympy.ntheory.residue_ntheory import quadratic_residues
818|    >>> quadratic_residues(7)
819|    [0, 1, 2, 4]
820|    """
821|    p = as_int(p)
822|    r = set()
823|    for i in range(p // 2 + 1):
824|        r.add(pow(i, 2, p))
825|    return sorted(list(r))
826|
827|
828|def legendre_symbol(a, p):
829|    r"""
830|    Returns the Legendre symbol `(a / p)`.
831|
832|    For an integer ``a`` and an odd prime ``p``, the Legendre symbol is
833|    defined as
834|
835|    .. math ::
836|        \genfrac(){}{}{a}{p} = \begin{cases}
837|             0 & \text{if } p \text{ divides } a\\
838|             1 & \text{if } a \text{ is a quadratic residue modulo } p\\
839|            -1 & \text{if } a \text{ is a quadratic nonresidue modulo } p
840|        \end{cases}
841|
842|    Parameters
843|    ==========
844|
845|    a : integer
846|    p : odd prime
847|
848|    Examples
849|    ========
850|
851|    >>> from sympy.ntheory import legendre_symbol
852|    >>> [legendre_symbol(i, 7) for i in range(7)]
853|    [0, 1, 1, -1, 1, -1, -1]
854|    >>> sorted(set([i**2 % 7 for i in range(7)]))
855|    [0, 1, 2, 4]
856|
857|    See Also
858|    ========
859|
860|    is_quad_residue, jacobi_symbol
861|
862|    """
863|    a, p = as_int(a), as_int(p)
864|    if not isprime(p) or p == 2:
865|        raise ValueError("p should be an odd prime")
866|    a = a % p
867|    if not a:
868|        return 0
869|    if pow(a, (p - 1) // 2, p) == 1:
870|        return 1
871|    return -1
872|
873|
874|def jacobi_symbol(m, n):
875|    r"""
876|    Returns the Jacobi symbol `(m / n)`.
877|
878|    For any integer ``m`` and any positive odd integer ``n`` the Jacobi symbol
879|    is defined as the product of the Legendre symbols corresponding to the
880|    prime factors of ``n``:
881|
882|    .. math ::
883|        \genfrac(){}{}{m}{n} =
884|            \genfrac(){}{}{m}{p^{1}}^{\alpha_1}
885|            \genfrac(){}{}{m}{p^{2}}^{\alpha_2}
886|            ...
887|            \genfrac(){}{}{m}{p^{k}}^{\alpha_k}
888|            \text{ where } n =
889|                p_1^{\alpha_1}
890|                p_2^{\alpha_2}
891|                ...
892|                p_k^{\alpha_k}
893|
894|    Like the Legendre symbol, if the Jacobi symbol `\genfrac(){}{}{m}{n} = -1`
895|    then ``m`` is a quadratic nonresidue modulo ``n``.
896|
897|    But, unlike the Legendre symbol, if the Jacobi symbol
898|    `\genfrac(){}{}{m}{n} = 1` then ``m`` may or may not be a quadratic residue
899|    modulo ``n``.
900|
901|    Parameters
902|    ==========
903|
904|    m : integer
905|    n : odd positive integer
906|
907|    Examples
908|    ========
909|
910|    >>> from sympy.ntheory import jacobi_symbol, legendre_symbol
911|    >>> from sympy import Mul, S
912|    >>> jacobi_symbol(45, 77)
913|    -1
914|    >>> jacobi_symbol(60, 121)
915|    1
916|
917|    The relationship between the ``jacobi_symbol`` and ``legendre_symbol`` can
918|    be demonstrated as follows:
919|
920|    >>> L = legendre_symbol
921|    >>> S(45).factors()
922|    {3: 2, 5: 1}
923|    >>> jacobi_symbol(7, 45) == L(7, 3)**2 * L(7, 5)**1
924|    True
925|
926|    See Also
927|    ========
928|
929|    is_quad_residue, legendre_symbol
930|    """
931|    m, n = as_int(m), as_int(n)
932|    if n < 0 or not n % 2:
933|        raise ValueError("n should be an odd positive integer")
934|    if m < 0 or m > n:
935|        m = m % n
936|    if not m:
937|        return int(n == 1)
938|    if n == 1 or m == 1:
939|        return 1
940|    if igcd(m, n) != 1:
941|        return 0
942|
943|    j = 1
944|    if m < 0:
945|        m = -m
946|        if n % 4 == 3:
947|            j = -j
948|    while m != 0:
949|        while m % 2 == 0 and m > 0:
950|            m >>= 1
951|            if n % 8 in [3, 5]:
952|                j = -j
953|        m, n = n, m
954|        if m % 4 == 3 and n % 4 == 3:
955|            j = -j
956|        m %= n
957|    if n != 1:
958|        j = 0
959|    return j
960|
961|
962|class mobius(Function):
963|    """
964|    Mobius function maps natural number to {-1, 0, 1}
965|
966|    It is defined as follows:
967|        1) `1` if `n = 1`.
968|        2) `0` if `n` has a squared prime factor.
969|        3) `(-1)^k` if `n` is a square-free positive integer with `k`
970|           number of prime factors.
971|
972|    It is an important multiplicative function in number theory
973|    and combinatorics.  It has applications in mathematical series,
974|    algebraic number theory and also physics (Fermion operator has very
975|    concrete realization with Mobius Function model).
976|
977|    Parameters
978|    ==========
979|
980|    n : positive integer
981|
982|    Examples
983|    ========
984|
985|    >>> from sympy.ntheory import mobius
986|    >>> mobius(13*7)
987|    1
988|    >>> mobius(1)
989|    1
990|    >>> mobius(13*7*5)
991|    -1
992|    >>> mobius(13**2)
993|    0
994|
995|    References
996|    ==========
997|
998|    .. [1] https://en.wikipedia.org/wiki/M%C3%B6bius_function
999|    .. [2] Thomas Koshy "Elementary Number Theory with Applications"
1000|
(302 more lines below)



============================================================



ACTION:

THOUGHT: Let me scroll down to find the `nthroot_mod` function:
CODE:
scroll_down()

============================================================



OBSERVATION:

[File: /workspace/sympy__sympy__1.6/sympy/ntheory/residue_ntheory.py (1302 lines total)]
(302 more lines above)
303|    """
304|    Iterate over solutions to ``x**2 = a mod p``
305|
306|    Parameters
307|    ==========
308|
309|    a : integer
310|    p : positive integer
311|    domain : integer domain, ``int``, ``ZZ`` or ``Integer``
312|
313|    Examples
314|    ========
315|
316|    >>> from sympy.ntheory.residue_ntheory import sqrt_mod_iter
317|    >>> list(sqrt_mod_iter(11, 43))
318|    [21, 22]
319|    """
320|    from sympy.polys.galoistools import gf_crt1, gf_crt2
321|    from sympy.polys.domains import ZZ
322|    a, p = as_int(a), abs(as_int(p))
323|    if isprime(p):
324|        a = a % p
325|        if a == 0:
326|            res = _sqrt_mod1(a, p, 1)
327|        else:
328|            res = _sqrt_mod_prime_power(a, p, 1)
329|        if res:
330|            if domain is ZZ:
331|                for x in res:
332|                    yield x
333|            else:
334|                for x in res:
335|                    yield domain(x)
336|    else:
337|        f = factorint(p)
338|        v = []
339|        pv = []
340|        for px, ex in f.items():
341|            if a % px == 0:
342|                rx = _sqrt_mod1(a, px, ex)
343|                if not rx:
344|                    return
345|            else:
346|                rx = _sqrt_mod_prime_power(a, px, ex)
347|                if not rx:
348|                    return
349|            v.append(rx)
350|            pv.append(px**ex)
351|        mm, e, s = gf_crt1(pv, ZZ)
352|        if domain is ZZ:
353|            for vx in _product(*v):
354|                r = gf_crt2(vx, pv, mm, e, s, ZZ)
355|                yield r
356|        else:
357|            for vx in _product(*v):
358|                r = gf_crt2(vx, pv, mm, e, s, ZZ)
359|                yield domain(r)
360|
361|
362|def _sqrt_mod_prime_power(a, p, k):
363|    """
364|    Find the solutions to ``x**2 = a mod p**k`` when ``a % p != 0``
365|
366|    Parameters
367|    ==========
368|
369|    a : integer
370|    p : prime number
371|    k : positive integer
372|
373|    Examples
374|    ========
375|
376|    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_prime_power
377|    >>> _sqrt_mod_prime_power(11, 43, 1)
378|    [21, 22]
379|
380|    References
381|    ==========
382|
383|    .. [1] P. Hackman "Elementary Number Theory" (2009), page 160
384|    .. [2] http://www.numbertheory.org/php/squareroot.html
385|    .. [3] [Gathen99]_
386|    """
387|    from sympy.core.numbers import igcdex
388|    from sympy.polys.domains import ZZ
389|
390|    pk = p**k
391|    a = a % pk
392|
393|    if k == 1:
394|        if p == 2:
395|            return [ZZ(a)]
396|        if not (a % p < 2 or pow(a, (p - 1) // 2, p) == 1):
397|            return None
398|
399|        if p % 4 == 3:
400|            res = pow(a, (p + 1) // 4, p)
401|        elif p % 8 == 5:
402|            sign = pow(a, (p - 1) // 4, p)
403|            if sign == 1:
404|                res = pow(a, (p + 3) // 8, p)
405|            else:
406|                b = pow(4*a, (p - 5) // 8, p)
407|                x =  (2*a*b) % p
408|                if pow(x, 2, p) == a:
409|                    res = x
410|        else:
411|            res = _sqrt_mod_tonelli_shanks(a, p)
412|
413|        # ``_sqrt_mod_tonelli_shanks(a, p)`` is not deterministic;
414|        # sort to get always the same result
415|        return sorted([ZZ(res), ZZ(p - res)])
416|
417|    if k > 1:
418|        # see Ref.[2]
419|        if p == 2:
420|            if a % 8 != 1:
421|                return None
422|            if k <= 3:
423|               s = set()
424|               for i in range(0, pk, 4):
425|                    s.add(1 + i)
426|                    s.add(-1 + i)
427|               return list(s)
428|            # according to Ref.[2] for k > 2 there are two solutions
429|            # (mod 2**k-1), that is four solutions (mod 2**k), which can be
430|            # obtained from the roots of x**2 = 0 (mod 8)
431|            rv = [ZZ(1), ZZ(3), ZZ(5), ZZ(7)]
432|            # hensel lift them to solutions of x**2 = 0 (mod 2**k)
433|            # if r**2 - a = 0 mod 2**nx but not mod 2**(nx+1)
434|            # then r + 2**(nx - 1) is a root mod 2**(nx+1)
435|            n = 3
436|            res = []
437|            for r in rv:
438|                nx = n
439|                while nx < k:
440|                    r1 = (r**2 - a) >> nx
441|                    if r1 % 2:
442|                        r = r + (1 << (nx - 1))
443|                    #assert (r**2 - a)% (1 << (nx + 1)) == 0
444|                    nx += 1
445|                if r not in res:
446|                    res.append(r)
447|                x = r + (1 << (k - 1))
448|                #assert (x**2 - a) % pk == 0
449|                if x < (1 << nx) and x not in res:
450|                    if (x**2 - a) % pk == 0:
451|                        res.append(x)
452|            return res
453|        rv = _sqrt_mod_prime_power(a, p, 1)
454|        if not rv:
455|            return None
456|        r = rv[0]
457|        fr = r**2 - a
458|        # hensel lifting with Newton iteration, see Ref.[3] chapter 9
459|        # with f(x) = x**2 - a; one has f'(a) != 0 (mod p) for p != 2
460|        n = 1
461|        px = p
462|        while 1:
463|            n1 = n
464|            n1 *= 2
465|            if n1 > k:
466|                break
467|            n = n1
468|            px = px**2
469|            frinv = igcdex(2*r, px)[0]
470|            r = (r - fr*frinv) % px
471|            fr = r**2 - a
472|        if n < k:
473|            px = p**k
474|            frinv = igcdex(2*r, px)[0]
475|            r = (r - fr*frinv) % px
476|        return [r, px - r]
477|
478|
479|def _sqrt_mod1(a, p, n):
480|    """
481|    Find solution to ``x**2 == a mod p**n`` when ``a % p == 0``
482|
483|    see http://www.numbertheory.org/php/squareroot.html
484|    """
485|    pn = p**n
486|    a = a % pn
487|    if a == 0:
488|        # case gcd(a, p**k) = p**n
489|        m = n // 2
490|        if n % 2 == 1:
491|            pm1 = p**(m + 1)
492|            def _iter0a():
493|                i = 0
494|                while i < pn:
495|                    yield i
496|                    i += pm1
497|            return _iter0a()
498|        else:
499|            pm = p**m
500|            def _iter0b():
501|                i = 0
502|                while i < pn:
503|                    yield i
504|                    i += pm
505|            return _iter0b()
506|
507|    # case gcd(a, p**k) = p**r, r < n
508|    f = factorint(a)
509|    r = f[p]
510|    if r % 2 == 1:
511|        return None
512|    m = r // 2
513|    a1 = a >> r
514|    if p == 2:
515|        if n - r == 1:
516|            pnm1 = 1 << (n - m + 1)
517|            pm1 = 1 << (m + 1)
518|            def _iter1():
519|                k = 1 << (m + 2)
520|                i = 1 << m
521|                while i < pnm1:
522|                    j = i
523|                    while j < pn:
524|                        yield j
525|                        j += k
526|                    i += pm1
527|            return _iter1()
528|        if n - r == 2:
529|            res = _sqrt_mod_prime_power(a1, p, n - r)
530|            if res is None:
531|                return None
532|            pnm = 1 << (n - m)
533|            def _iter2():
534|                s = set()
535|                for r in res:
536|                    i = 0
537|                    while i < pn:
538|                        x = (r << m) + i
539|                        if x not in s:
540|                            s.add(x)
541|                            yield x
542|                        i += pnm
543|            return _iter2()
544|        if n - r > 2:
545|            res = _sqrt_mod_prime_power(a1, p, n - r)
546|            if res is None:
547|                return None
548|            pnm1 = 1 << (n - m - 1)
549|            def _iter3():
550|                s = set()
551|                for r in res:
552|                    i = 0
553|                    while i < pn:
554|                        x = ((r << m) + i) % pn
555|                        if x not in s:
556|                            s.add(x)
557|                            yield x
558|                        i += pnm1
559|            return _iter3()
560|    else:
561|        m = r // 2
562|        a1 = a // p**r
563|        res1 = _sqrt_mod_prime_power(a1, p, n - r)
564|        if res1 is None:
565|            return None
566|        pm = p**m
567|        pnr = p**(n-r)
568|        pnm = p**(n-m)
569|
570|        def _iter4():
571|            s = set()
572|            pm = p**m
573|            for rx in res1:
574|                i = 0
575|                while i < pnm:
576|                    x = ((rx + i) % pn)
577|                    if x not in s:
578|                        s.add(x)
579|                        yield x*pm
580|                    i += pnr
581|        return _iter4()
582|
583|
584|def is_quad_residue(a, p):
585|    """
586|    Returns True if ``a`` (mod ``p``) is in the set of squares mod ``p``,
587|    i.e a % p in set([i**2 % p for i in range(p)]). If ``p`` is an odd
588|    prime, an iterative method is used to make the determination:
589|
590|    >>> from sympy.ntheory import is_quad_residue
591|    >>> sorted(set([i**2 % 7 for i in range(7)]))
592|    [0, 1, 2, 4]
593|    >>> [j for j in range(7) if is_quad_residue(j, 7)]
594|    [0, 1, 2, 4]
595|
596|    See Also
597|    ========
598|
599|    legendre_symbol, jacobi_symbol
600|    """
601|    a, p = as_int(a), as_int(p)
602|    if p < 1:
603|        raise ValueError('p must be > 0')
604|    if a >= p or a < 0:
605|        a = a % p
606|    if a < 2 or p < 3:
607|        return True
608|    if not isprime(p):
609|        if p % 2 and jacobi_symbol(a, p) == -1:
610|            return False
611|        r = sqrt_mod(a, p)
612|        if r is None:
613|            return False
614|        else:
615|            return True
616|
617|    return pow(a, (p - 1) // 2, p) == 1
618|
619|
620|def is_nthpow_residue(a, n, m):
621|    """
622|    Returns True if ``x**n == a (mod m)`` has solutions.
623|
624|    References
625|    ==========
626|
627|    .. [1] P. Hackman "Elementary Number Theory" (2009), page 76
628|
629|    """
630|    a, n, m = as_int(a), as_int(n), as_int(m)
631|    if m <= 0:
632|        raise ValueError('m must be > 0')
633|    if n < 0:
634|        raise ValueError('n must be >= 0')
635|    if a < 0:
636|        raise ValueError('a must be >= 0')
637|    if n == 0:
638|        if m == 1:
639|            return False
640|        return a == 1
641|    if a % m == 0:
642|        return True
643|    if n == 1:
644|        return True
645|    if n == 2:
646|        return is_quad_residue(a, m)
647|    return _is_nthpow_residue_bign(a, n, m)
648|
649|
650|def _is_nthpow_residue_bign(a, n, m):
651|    """Returns True if ``x**n == a (mod m)`` has solutions for n > 2."""
652|    # assert n > 2
653|    # assert a > 0 and m > 0
654|    if primitive_root(m) is None:
655|        # assert m >= 8
656|        for prime, power in factorint(m).items():
657|            if not _is_nthpow_residue_bign_prime_power(a, n, prime, power):
658|                return False
659|        return True
660|    f = totient(m)
661|    k = f // igcd(f, n)
662|    return pow(a, k, m) == 1
663|
664|
665|def _is_nthpow_residue_bign_prime_power(a, n, p, k):
666|    """Returns True/False if a solution for ``x**n == a (mod(p**k))``
667|    does/doesn't exist."""
668|    # assert a > 0
669|    # assert n > 2
670|    # assert p is prime
671|    # assert k > 0
672|    if a % p:
673|        if p != 2:
674|            return _is_nthpow_residue_bign(a, n, pow(p, k))
675|        if n & 1:
676|            return True
677|        c = trailing(n)
678|        return a % pow(2, min(c + 2, k)) == 1
679|    else:
680|        a %= pow(p, k)
681|        if not a:
682|            return True
683|        mu = multiplicity(p, a)
684|        if mu % n:
685|            return False
686|        pm = pow(p, mu)
687|        return _is_nthpow_residue_bign_prime_power(a//pm, n, p, k - mu)
688|
689|
690|def _nthroot_mod2(s, q, p):
691|    f = factorint(q)
692|    v = []
693|    for b, e in f.items():
694|        v.extend([b]*e)
695|    for qx in v:
696|        s = _nthroot_mod1(s, qx, p, False)
697|    return s
698|
699|
700|def _nthroot_mod1(s, q, p, all_roots):
701|    """
702|    Root of ``x**q = s mod p``, ``p`` prime and ``q`` divides ``p - 1``
703|
704|    References
705|    ==========
706|
707|    .. [1] A. M. Johnston "A Generalized qth Root Algorithm"
708|
709|    """
710|    g = primitive_root(p)
711|    if not isprime(q):
712|        r = _nthroot_mod2(s, q, p)
713|    else:
714|        f = p - 1
715|        assert (p - 1) % q == 0
716|        # determine k
717|        k = 0
718|        while f % q == 0:
719|            k += 1
720|            f = f // q
721|        # find z, x, r1
722|        f1 = igcdex(-f, q)[0] % q
723|        z = f*f1
724|        x = (1 + z) // q
725|        r1 = pow(s, x, p)
726|        s1 = pow(s, f, p)
727|        h = pow(g, f*q, p)
728|        t = discrete_log(p, s1, h)
729|        g2 = pow(g, z*t, p)
730|        g3 = igcdex(g2, p)[0]
731|        r = r1*g3 % p
732|        #assert pow(r, q, p) == s
733|    res = [r]
734|    h = pow(g, (p - 1) // q, p)
735|    #assert pow(h, q, p) == 1
736|    hx = r
737|    for i in range(q - 1):
738|        hx = (hx*h) % p
739|        res.append(hx)
740|    if all_roots:
741|        res.sort()
742|        return res
743|    return min(res)
744|
745|
746|def nthroot_mod(a, n, p, all_roots=False):
747|    """
748|    Find the solutions to ``x**n = a mod p``
749|
750|    Parameters
751|    ==========
752|
753|    a : integer
754|    n : positive integer
755|    p : positive integer
756|    all_roots : if False returns the smallest root, else the list of roots
757|
758|    Examples
759|    ========
760|
761|    >>> from sympy.ntheory.residue_ntheory import nthroot_mod
762|    >>> nthroot_mod(11, 4, 19)
763|    8
764|    >>> nthroot_mod(11, 4, 19, True)
765|    [8, 11]
766|    >>> nthroot_mod(68, 3, 109)
767|    23
768|    """
769|    from sympy.core.numbers import igcdex
770|    a, n, p = as_int(a), as_int(n), as_int(p)
771|    if n == 2:
772|        return sqrt_mod(a, p, all_roots)
773|    # see Hackman "Elementary Number Theory" (2009), page 76
774|    if not is_nthpow_residue(a, n, p):
775|        return None
776|    if not isprime(p):
777|        raise NotImplementedError("Not implemented for composite p")
778|
779|    if (p - 1) % n == 0:
780|        return _nthroot_mod1(a, n, p, all_roots)
781|    # The roots of ``x**n - a = 0 (mod p)`` are roots of
782|    # ``gcd(x**n - a, x**(p - 1) - 1) = 0 (mod p)``
783|    pa = n
784|    pb = p - 1
785|    b = 1
786|    if pa < pb:
787|        a, pa, b, pb = b, pb, a, pa
788|    while pb:
789|        # x**pa - a = 0; x**pb - b = 0
790|        # x**pa - a = x**(q*pb + r) - a = (x**pb)**q * x**r - a =
791|        #             b**q * x**r - a; x**r - c = 0; c = b**-q * a mod p
792|        q, r = divmod(pa, pb)
793|        c = pow(b, q, p)
794|        c = igcdex(c, p)[0]
795|        c = (c * a) % p
796|        pa, pb = pb, r
797|        a, b = b, c
798|    if pa == 1:
799|        if all_roots:
800|            res = [a]
801|        else:
802|            res = a
803|    elif pa == 2:
804|        return sqrt_mod(a, p , all_roots)
805|    else:
806|        res = _nthroot_mod1(a, pa, p, all_roots)
807|    return res
808|
809|
810|def quadratic_residues(p):
811|    """
812|    Returns the list of quadratic residues.
813|
814|    Examples
815|    ========
816|
817|    >>> from sympy.ntheory.residue_ntheory import quadratic_residues
818|    >>> quadratic_residues(7)
819|    [0, 1, 2, 4]
820|    """
821|    p = as_int(p)
822|    r = set()
823|    for i in range(p // 2 + 1):
824|        r.add(pow(i, 2, p))
825|    return sorted(list(r))
826|
827|
828|def legendre_symbol(a, p):
829|    r"""
830|    Returns the Legendre symbol `(a / p)`.
831|
832|    For an integer ``a`` and an odd prime ``p``, the Legendre symbol is
833|    defined as
834|
835|    .. math ::
836|        \genfrac(){}{}{a}{p} = \begin{cases}
837|             0 & \text{if } p \text{ divides } a\\
838|             1 & \text{if } a \text{ is a quadratic residue modulo } p\\
839|            -1 & \text{if } a \text{ is a quadratic nonresidue modulo } p
840|        \end{cases}
841|
842|    Parameters
843|    ==========
844|
845|    a : integer
846|    p : odd prime
847|
848|    Examples
849|    ========
850|
851|    >>> from sympy.ntheory import legendre_symbol
852|    >>> [legendre_symbol(i, 7) for i in range(7)]
853|    [0, 1, 1, -1, 1, -1, -1]
854|    >>> sorted(set([i**2 % 7 for i in range(7)]))
855|    [0, 1, 2, 4]
856|
857|    See Also
858|    ========
859|
860|    is_quad_residue, jacobi_symbol
861|
862|    """
863|    a, p = as_int(a), as_int(p)
864|    if not isprime(p) or p == 2:
865|        raise ValueError("p should be an odd prime")
866|    a = a % p
867|    if not a:
868|        return 0
869|    if pow(a, (p - 1) // 2, p) == 1:
870|        return 1
871|    return -1
872|
873|
874|def jacobi_symbol(m, n):
875|    r"""
876|    Returns the Jacobi symbol `(m / n)`.
877|
878|    For any integer ``m`` and any positive odd integer ``n`` the Jacobi symbol
879|    is defined as the product of the Legendre symbols corresponding to the
880|    prime factors of ``n``:
881|
882|    .. math ::
883|        \genfrac(){}{}{m}{n} =
884|            \genfrac(){}{}{m}{p^{1}}^{\alpha_1}
885|            \genfrac(){}{}{m}{p^{2}}^{\alpha_2}
886|            ...
887|            \genfrac(){}{}{m}{p^{k}}^{\alpha_k}
888|            \text{ where } n =
889|                p_1^{\alpha_1}
890|                p_2^{\alpha_2}
891|                ...
892|                p_k^{\alpha_k}
893|
894|    Like the Legendre symbol, if the Jacobi symbol `\genfrac(){}{}{m}{n} = -1`
895|    then ``m`` is a quadratic nonresidue modulo ``n``.
896|
897|    But, unlike the Legendre symbol, if the Jacobi symbol
898|    `\genfrac(){}{}{m}{n} = 1` then ``m`` may or may not be a quadratic residue
899|    modulo ``n``.
900|
901|    Parameters
902|    ==========
903|
904|    m : integer
905|    n : odd positive integer
906|
907|    Examples
908|    ========
909|
910|    >>> from sympy.ntheory import jacobi_symbol, legendre_symbol
911|    >>> from sympy import Mul, S
912|    >>> jacobi_symbol(45, 77)
913|    -1
914|    >>> jacobi_symbol(60, 121)
915|    1
916|
917|    The relationship between the ``jacobi_symbol`` and ``legendre_symbol`` can
918|    be demonstrated as follows:
919|
920|    >>> L = legendre_symbol
921|    >>> S(45).factors()
922|    {3: 2, 5: 1}
923|    >>> jacobi_symbol(7, 45) == L(7, 3)**2 * L(7, 5)**1
924|    True
925|
926|    See Also
927|    ========
928|
929|    is_quad_residue, legendre_symbol
930|    """
931|    m, n = as_int(m), as_int(n)
932|    if n < 0 or not n % 2:
933|        raise ValueError("n should be an odd positive integer")
934|    if m < 0 or m > n:
935|        m = m % n
936|    if not m:
937|        return int(n == 1)
938|    if n == 1 or m == 1:
939|        return 1
940|    if igcd(m, n) != 1:
941|        return 0
942|
943|    j = 1
944|    if m < 0:
945|        m = -m
946|        if n % 4 == 3:
947|            j = -j
948|    while m != 0:
949|        while m % 2 == 0 and m > 0:
950|            m >>= 1
951|            if n % 8 in [3, 5]:
952|                j = -j
953|        m, n = n, m
954|        if m % 4 == 3 and n % 4 == 3:
955|            j = -j
956|        m %= n
957|    if n != 1:
958|        j = 0
959|    return j
960|
961|
962|class mobius(Function):
963|    """
964|    Mobius function maps natural number to {-1, 0, 1}
965|
966|    It is defined as follows:
967|        1) `1` if `n = 1`.
968|        2) `0` if `n` has a squared prime factor.
969|        3) `(-1)^k` if `n` is a square-free positive integer with `k`
970|           number of prime factors.
971|
972|    It is an important multiplicative function in number theory
973|    and combinatorics.  It has applications in mathematical series,
974|    algebraic number theory and also physics (Fermion operator has very
975|    concrete realization with Mobius Function model).
976|
977|    Parameters
978|    ==========
979|
980|    n : positive integer
981|
982|    Examples
983|    ========
984|
985|    >>> from sympy.ntheory import mobius
986|    >>> mobius(13*7)
987|    1
988|    >>> mobius(1)
989|    1
990|    >>> mobius(13*7*5)
991|    -1
992|    >>> mobius(13**2)
993|    0
994|
995|    References
996|    ==========
997|
998|    .. [1] https://en.wikipedia.org/wiki/M%C3%B6bius_function
999|    .. [2] Thomas Koshy "Elementary Number Theory with Applications"
1000|
1001|    """
1002|    @classmethod
1003|    def eval(cls, n):
1004|        if n.is_integer:
1005|            if n.is_positive is not True:
1006|                raise ValueError("n should be a positive integer")
1007|        else:
1008|            raise TypeError("n should be an integer")
1009|        if n.is_prime:
1010|            return S.NegativeOne
1011|        elif n is S.One:
1012|            return S.One
1013|        elif n.is_Integer:
1014|            a = factorint(n)
1015|            if any(i > 1 for i in a.values()):
1016|                return S.Zero
1017|            return S.NegativeOne**len(a)
1018|
1019|
1020|def _discrete_log_trial_mul(n, a, b, order=None):
1021|    """
1022|    Trial multiplication algorithm for computing the discrete logarithm of
1023|    ``a`` to the base ``b`` modulo ``n``.
1024|
1025|    The algorithm finds the discrete logarithm using exhaustive search. This
1026|    naive method is used as fallback algorithm of ``discrete_log`` when the
1027|    group order is very small.
1028|
1029|    Examples
1030|    ========
1031|
1032|    >>> from sympy.ntheory.residue_ntheory import _discrete_log_trial_mul
1033|    >>> _discrete_log_trial_mul(41, 15, 7)
1034|    3
1035|
1036|    See Also
1037|    ========
1038|
1039|    discrete_log
1040|
1041|    References
1042|    ==========
1043|
1044|    .. [1] "Handbook of applied cryptography", Menezes, A. J., Van, O. P. C., &
1045|        Vanstone, S. A. (1997).
1046|    """
1047|    a %= n
1048|    b %= n
1049|    if order is None:
1050|        order = n
1051|    x = 1
1052|    for i in range(order):
1053|        if x == a:
1054|            return i
1055|        x = x * b % n
1056|    raise ValueError("Log does not exist")
1057|
1058|
1059|def _discrete_log_shanks_steps(n, a, b, order=None):
1060|    """
1061|    Baby-step giant-step algorithm for computing the discrete logarithm of
1062|    ``a`` to the base ``b`` modulo ``n``.
1063|
1064|    The algorithm is a time-memory trade-off of the method of exhaustive
1065|    search. It uses `O(sqrt(m))` memory, where `m` is the group order.
1066|
1067|    Examples
1068|    ========
1069|
1070|    >>> from sympy.ntheory.residue_ntheory import _discrete_log_shanks_steps
1071|    >>> _discrete_log_shanks_steps(41, 15, 7)
1072|    3
1073|
1074|    See Also
1075|    ========
1076|
1077|    discrete_log
1078|
1079|    References
1080|    ==========
1081|
1082|    .. [1] "Handbook of applied cryptography", Menezes, A. J., Van, O. P. C., &
1083|        Vanstone, S. A. (1997).
1084|    """
1085|    a %= n
1086|    b %= n
1087|    if order is None:
1088|        order = n_order(b, n)
1089|    m = isqrt(order) + 1
1090|    T = dict()
1091|    x = 1
1092|    for i in range(m):
1093|        T[x] = i
1094|        x = x * b % n
1095|    z = mod_inverse(b, n)
1096|    z = pow(z, m, n)
1097|    x = a
1098|    for i in range(m):
1099|        if x in T:
1100|            return i * m + T[x]
1101|        x = x * z % n
1102|    raise ValueError("Log does not exist")
1103|
1104|
1105|def _discrete_log_pollard_rho(n, a, b, order=None, retries=10, rseed=None):
1106|    """
1107|    Pollard's Rho algorithm for computing the discrete logarithm of ``a`` to
1108|    the base ``b`` modulo ``n``.
1109|
1110|    It is a randomized algorithm with the same expected running time as
1111|    ``_discrete_log_shanks_steps``, but requires a negligible amount of memory.
1112|
1113|    Examples
1114|    ========
1115|
1116|    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pollard_rho
1117|    >>> _discrete_log_pollard_rho(227, 3**7, 3)
1118|    7
1119|
1120|    See Also
1121|    ========
1122|
1123|    discrete_log
1124|
1125|    References
1126|    ==========
1127|
1128|    .. [1] "Handbook of applied cryptography", Menezes, A. J., Van, O. P. C., &
1129|        Vanstone, S. A. (1997).
1130|    """
1131|    a %= n
1132|    b %= n
1133|
1134|    if order is None:
1135|        order = n_order(b, n)
1136|    prng = Random()
1137|    if rseed is not None:
1138|        prng.seed(rseed)
1139|
1140|    for i in range(retries):
1141|        aa = prng.randint(1, order - 1)
1142|        ba = prng.randint(1, order - 1)
1143|        xa = pow(b, aa, n) * pow(a, ba, n) % n
1144|
1145|        c = xa % 3
1146|        if c == 0:
1147|            xb = a * xa % n
1148|            ab = aa
1149|            bb = (ba + 1) % order
1150|        elif c == 1:
1151|            xb = xa * xa % n
1152|            ab = (aa + aa) % order
1153|            bb = (ba + ba) % order
1154|        else:
1155|            xb = b * xa % n
1156|            ab = (aa + 1) % order
1157|            bb = ba
1158|
1159|        for j in range(order):
1160|            c = xa % 3
1161|            if c == 0:
1162|                xa = a * xa % n
1163|                ba = (ba + 1) % order
1164|            elif c == 1:
1165|                xa = xa * xa % n
1166|                aa = (aa + aa) % order
1167|                ba = (ba + ba) % order
1168|            else:
1169|                xa = b * xa % n
1170|                aa = (aa + 1) % order
1171|
1172|            c = xb % 3
1173|            if c == 0:
1174|                xb = a * xb % n
1175|                bb = (bb + 1) % order
1176|            elif c == 1:
1177|                xb = xb * xb % n
1178|                ab = (ab + ab) % order
1179|                bb = (bb + bb) % order
1180|            else:
1181|                xb = b * xb % n
1182|                ab = (ab + 1) % order
1183|
1184|            c = xb % 3
1185|            if c == 0:
1186|                xb = a * xb % n
1187|                bb = (bb + 1) % order
1188|            elif c == 1:
1189|                xb = xb * xb % n
1190|                ab = (ab + ab) % order
1191|                bb = (bb + bb) % order
1192|            else:
1193|                xb = b * xb % n
1194|                ab = (ab + 1) % order
1195|
1196|            if xa == xb:
1197|                r = (ba - bb) % order
1198|                try:
1199|                    e = mod_inverse(r, order) * (ab - aa) % order
1200|                    if (pow(b, e, n) - a) % n == 0:
1201|                        return e
1202|                except ValueError:
1203|                    pass
1204|                break
1205|    raise ValueError("Pollard's Rho failed to find logarithm")
1206|
1207|
1208|def _discrete_log_pohlig_hellman(n, a, b, order=None):
1209|    """
1210|    Pohlig-Hellman algorithm for computing the discrete logarithm of ``a`` to
1211|    the base ``b`` modulo ``n``.
1212|
1213|    In order to compute the discrete logarithm, the algorithm takes advantage
1214|    of the factorization of the group order. It is more efficient when the
1215|    group order factors into many small primes.
1216|
1217|    Examples
1218|    ========
1219|
1220|    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pohlig_hellman
1221|    >>> _discrete_log_pohlig_hellman(251, 210, 71)
1222|    197
1223|
1224|    See Also
1225|    ========
1226|
1227|    discrete_log
1228|
1229|    References
1230|    ==========
1231|
1232|    .. [1] "Handbook of applied cryptography", Menezes, A. J., Van, O. P. C., &
1233|        Vanstone, S. A. (1997).
1234|    """
1235|    from .modular import crt
1236|    a %= n
1237|    b %= n
1238|
1239|    if order is None:
1240|        order = n_order(b, n)
1241|
1242|    f = factorint(order)
1243|    l = [0] * len(f)
1244|
1245|    for i, (pi, ri) in enumerate(f.items()):
1246|        for j in range(ri):
1247|            gj = pow(b, l[i], n)
1248|            aj = pow(a * mod_inverse(gj, n), order // pi**(j + 1), n)
1249|            bj = pow(b, order // pi, n)
1250|            cj = discrete_log(n, aj, bj, pi, True)
1251|            l[i] += cj * pi**j
1252|
1253|    d, _ = crt([pi**ri for pi, ri in f.items()], l)
1254|    return d
1255|
1256|
1257|def discrete_log(n, a, b, order=None, prime_order=None):
1258|    """
1259|    Compute the discrete logarithm of ``a`` to the base ``b`` modulo ``n``.
1260|
1261|    This is a recursive function to reduce the discrete logarithm problem in
1262|    cyclic groups of composite order to the problem in cyclic groups of prime
1263|    order.
1264|
1265|    It employs different algorithms depending on the problem (subgroup order
1266|    size, prime order or not):
1267|
1268|        * Trial multiplication
1269|        * Baby-step giant-step
1270|        * Pollard's Rho
1271|        * Pohlig-Hellman
1272|
1273|    Examples
1274|    ========
1275|
1276|    >>> from sympy.ntheory import discrete_log
1277|    >>> discrete_log(41, 15, 7)
1278|    3
1279|
1280|    References
1281|    ==========
1282|
1283|    .. [1] http://mathworld.wolfram.com/DiscreteLogarithm.html
1284|    .. [2] "Handbook of applied cryptography", Menezes, A. J., Van, O. P. C., &
1285|        Vanstone, S. A. (1997).
1286|
1287|    """
1288|    n, a, b = as_int(n), as_int(a), as_int(b)
1289|    if order is None:
1290|        order = n_order(b, n)
1291|
1292|    if prime_order is None:
1293|        prime_order = isprime(order)
1294|
1295|    if order < 1000:
1296|        return _discrete_log_trial_mul(n, a, b, order)
1297|    elif prime_order:
1298|        if order < 1000000000000:
1299|            return _discrete_log_shanks_steps(n, a, b, order)
1300|        return _discrete_log_pollard_rho(n, a, b, order)
1301|
1302|    return _discrete_log_pohlig_hellman(n, a, b, order)


============================================================



ACTION:

THOUGHT: Let me search for `nthroot_mod` as it wasn't visible in the current view:
CODE:
search_file("nthroot_mod", "/workspace/sympy__sympy__1.6/sympy/ntheory/residue_ntheory.py")

============================================================



OBSERVATION:

[Found 11 matches for "nthroot_mod" in /workspace/sympy__sympy__1.6/sympy/ntheory/residue_ntheory.py]
Line 690: def _nthroot_mod2(s, q, p):
Line 696: s = _nthroot_mod1(s, qx, p, False)
Line 700: def _nthroot_mod1(s, q, p, all_roots):
Line 712: r = _nthroot_mod2(s, q, p)
Line 746: def nthroot_mod(a, n, p, all_roots=False):
Line 761: >>> from sympy.ntheory.residue_ntheory import nthroot_mod
Line 762: >>> nthroot_mod(11, 4, 19)
Line 764: >>> nthroot_mod(11, 4, 19, True)
Line 766: >>> nthroot_mod(68, 3, 109)
Line 780: return _nthroot_mod1(a, n, p, all_roots)
Line 806: res = _nthroot_mod1(a, pa, p, all_roots)
[End of matches for "nthroot_mod" in /workspace/sympy__sympy__1.6/sympy/ntheory/residue_ntheory.py]



============================================================



ACTION:

THOUGHT: Let me check the implementation of `nthroot_mod` and its helper functions:
CODE:
open_file("/workspace/sympy__sympy__1.6/sympy/ntheory/residue_ntheory.py", 746)

============================================================



OBSERVATION:

[File: /workspace/sympy__sympy__1.6/sympy/ntheory/residue_ntheory.py (1302 lines total)]
(645 more lines above)
646|        return is_quad_residue(a, m)
647|    return _is_nthpow_residue_bign(a, n, m)
648|
649|
650|def _is_nthpow_residue_bign(a, n, m):
651|    """Returns True if ``x**n == a (mod m)`` has solutions for n > 2."""
652|    # assert n > 2
653|    # assert a > 0 and m > 0
654|    if primitive_root(m) is None:
655|        # assert m >= 8
656|        for prime, power in factorint(m).items():
657|            if not _is_nthpow_residue_bign_prime_power(a, n, prime, power):
658|                return False
659|        return True
660|    f = totient(m)
661|    k = f // igcd(f, n)
662|    return pow(a, k, m) == 1
663|
664|
665|def _is_nthpow_residue_bign_prime_power(a, n, p, k):
666|    """Returns True/False if a solution for ``x**n == a (mod(p**k))``
667|    does/doesn't exist."""
668|    # assert a > 0
669|    # assert n > 2
670|    # assert p is prime
671|    # assert k > 0
672|    if a % p:
673|        if p != 2:
674|            return _is_nthpow_residue_bign(a, n, pow(p, k))
675|        if n & 1:
676|            return True
677|        c = trailing(n)
678|        return a % pow(2, min(c + 2, k)) == 1
679|    else:
680|        a %= pow(p, k)
681|        if not a:
682|            return True
683|        mu = multiplicity(p, a)
684|        if mu % n:
685|            return False
686|        pm = pow(p, mu)
687|        return _is_nthpow_residue_bign_prime_power(a//pm, n, p, k - mu)
688|
689|
690|def _nthroot_mod2(s, q, p):
691|    f = factorint(q)
692|    v = []
693|    for b, e in f.items():
694|        v.extend([b]*e)
695|    for qx in v:
696|        s = _nthroot_mod1(s, qx, p, False)
697|    return s
698|
699|
700|def _nthroot_mod1(s, q, p, all_roots):
701|    """
702|    Root of ``x**q = s mod p``, ``p`` prime and ``q`` divides ``p - 1``
703|
704|    References
705|    ==========
706|
707|    .. [1] A. M. Johnston "A Generalized qth Root Algorithm"
708|
709|    """
710|    g = primitive_root(p)
711|    if not isprime(q):
712|        r = _nthroot_mod2(s, q, p)
713|    else:
714|        f = p - 1
715|        assert (p - 1) % q == 0
716|        # determine k
717|        k = 0
718|        while f % q == 0:
719|            k += 1
720|            f = f // q
721|        # find z, x, r1
722|        f1 = igcdex(-f, q)[0] % q
723|        z = f*f1
724|        x = (1 + z) // q
725|        r1 = pow(s, x, p)
726|        s1 = pow(s, f, p)
727|        h = pow(g, f*q, p)
728|        t = discrete_log(p, s1, h)
729|        g2 = pow(g, z*t, p)
730|        g3 = igcdex(g2, p)[0]
731|        r = r1*g3 % p
732|        #assert pow(r, q, p) == s
733|    res = [r]
734|    h = pow(g, (p - 1) // q, p)
735|    #assert pow(h, q, p) == 1
736|    hx = r
737|    for i in range(q - 1):
738|        hx = (hx*h) % p
739|        res.append(hx)
740|    if all_roots:
741|        res.sort()
742|        return res
743|    return min(res)
744|
745|
746|def nthroot_mod(a, n, p, all_roots=False):
747|    """
748|    Find the solutions to ``x**n = a mod p``
749|
750|    Parameters
751|    ==========
752|
753|    a : integer
754|    n : positive integer
755|    p : positive integer
756|    all_roots : if False returns the smallest root, else the list of roots
757|
758|    Examples
759|    ========
760|
761|    >>> from sympy.ntheory.residue_ntheory import nthroot_mod
762|    >>> nthroot_mod(11, 4, 19)
763|    8
764|    >>> nthroot_mod(11, 4, 19, True)
765|    [8, 11]
766|    >>> nthroot_mod(68, 3, 109)
767|    23
768|    """
769|    from sympy.core.numbers import igcdex
770|    a, n, p = as_int(a), as_int(n), as_int(p)
771|    if n == 2:
772|        return sqrt_mod(a, p, all_roots)
773|    # see Hackman "Elementary Number Theory" (2009), page 76
774|    if not is_nthpow_residue(a, n, p):
775|        return None
776|    if not isprime(p):
777|        raise NotImplementedError("Not implemented for composite p")
778|
779|    if (p - 1) % n == 0:
780|        return _nthroot_mod1(a, n, p, all_roots)
781|    # The roots of ``x**n - a = 0 (mod p)`` are roots of
782|    # ``gcd(x**n - a, x**(p - 1) - 1) = 0 (mod p)``
783|    pa = n
784|    pb = p - 1
785|    b = 1
786|    if pa < pb:
787|        a, pa, b, pb = b, pb, a, pa
788|    while pb:
789|        # x**pa - a = 0; x**pb - b = 0
790|        # x**pa - a = x**(q*pb + r) - a = (x**pb)**q * x**r - a =
791|        #             b**q * x**r - a; x**r - c = 0; c = b**-q * a mod p
792|        q, r = divmod(pa, pb)
793|        c = pow(b, q, p)
794|        c = igcdex(c, p)[0]
795|        c = (c * a) % p
796|        pa, pb = pb, r
797|        a, b = b, c
798|    if pa == 1:
799|        if all_roots:
800|            res = [a]
801|        else:
802|            res = a
803|    elif pa == 2:
804|        return sqrt_mod(a, p , all_roots)
805|    else:
806|        res = _nthroot_mod1(a, pa, p, all_roots)
807|    return res
808|
809|
810|def quadratic_residues(p):
811|    """
812|    Returns the list of quadratic residues.
813|
814|    Examples
815|    ========
816|
817|    >>> from sympy.ntheory.residue_ntheory import quadratic_residues
818|    >>> quadratic_residues(7)
819|    [0, 1, 2, 4]
820|    """
821|    p = as_int(p)
822|    r = set()
823|    for i in range(p // 2 + 1):
824|        r.add(pow(i, 2, p))
825|    return sorted(list(r))
826|
827|
828|def legendre_symbol(a, p):
829|    r"""
830|    Returns the Legendre symbol `(a / p)`.
831|
832|    For an integer ``a`` and an odd prime ``p``, the Legendre symbol is
833|    defined as
834|
835|    .. math ::
836|        \genfrac(){}{}{a}{p} = \begin{cases}
837|             0 & \text{if } p \text{ divides } a\\
838|             1 & \text{if } a \text{ is a quadratic residue modulo } p\\
839|            -1 & \text{if } a \text{ is a quadratic nonresidue modulo } p
840|        \end{cases}
841|
842|    Parameters
843|    ==========
844|
845|    a : integer
846|    p : odd prime
(456 more lines below)


============================================================



OBSERVATION:

Task: 

============================================================



OBSERVATION:

Planner Invoked

============================================================



ACTION:

THOUGHT: The plan looks good. Let me proceed with implementing the fix:
CODE:
DIFF_STRING = """<<<<<<< SEARCH
def nthroot_mod(a, n, p, all_roots=False):
    \"\"\"
    Find the solutions to ``x**n = a mod p``

    Parameters
    ==========

    a : integer
    n : positive integer
    p : positive integer
    all_roots : if False returns the smallest root, else the list of roots

    Examples
    ========

    >>> from sympy.ntheory.residue_ntheory import nthroot_mod
    >>> nthroot_mod(11, 4, 19)
    8
    >>> nthroot_mod(11, 4, 19, True)
    [8, 11]
    >>> nthroot_mod(68, 3, 109)
    23
    \"\"\"
    from sympy.core.numbers import igcdex
    a, n, p = as_int(a), as_int(n), as_int(p)
=======
def nthroot_mod(a, n, p, all_roots=False):
    \"\"\"
    Find the solutions to ``x**n = a mod p``

    Parameters
    ==========

    a : integer
    n : positive integer
    p : positive integer
    all_roots : if False returns the smallest root, else the list of roots

    Examples
    ========

    >>> from sympy.ntheory.residue_ntheory import nthroot_mod
    >>> nthroot_mod(11, 4, 19)
    8
    >>> nthroot_mod(11, 4, 19, True)
    [8, 11]
    >>> nthroot_mod(68, 3, 109)
    23
    \"\"\"
    from sympy.core.numbers import igcdex
    a, n, p = as_int(a), as_int(n), as_int(p)
    
    # Handle case where a ≡ 0 (mod p)
    if a % p == 0:
        return [0] if all_roots else 0
>>>>>>> REPLACE"""
edit_file('/workspace/sympy__sympy__1.6/sympy/ntheory/residue_ntheory.py', diff_string=DIFF_STRING)

============================================================



OBSERVATION:

[File: /workspace/sympy__sympy__1.6/sympy/ntheory/residue_ntheory.py (1306 lines total after edit)]
[Diff of the changes applied. Please review the diff and remove if there are any redundant code lines or duplicates introduced or left to be removed.]
--- 
+++ 
@@ -741,60 +741,64 @@
         res.sort()
         return res
     return min(res)
 
 
 def nthroot_mod(a, n, p, all_roots=False):
     """
     Find the solutions to ``x**n = a mod p``
 
     Parameters
     ==========
 
     a : integer
     n : positive integer
     p : positive integer
     all_roots : if False returns the smallest root, else the list of roots
 
     Examples
     ========
 
     >>> from sympy.ntheory.residue_ntheory import nthroot_mod
     >>> nthroot_mod(11, 4, 19)
     8
     >>> nthroot_mod(11, 4, 19, True)
     [8, 11]
     >>> nthroot_mod(68, 3, 109)
     23
     """
     from sympy.core.numbers import igcdex
     a, n, p = as_int(a), as_int(n), as_int(p)
+    
+    # Handle case where a ≡ 0 (mod p)
+    if a % p == 0:
+        return [0] if all_roots else 0
     if n == 2:
         return sqrt_mod(a, p, all_roots)
     # see Hackman "Elementary Number Theory" (2009), page 76
     if not is_nthpow_residue(a, n, p):
         return None
     if not isprime(p):
         raise NotImplementedError("Not implemented for composite p")
 
     if (p - 1) % n == 0:
         return _nthroot_mod1(a, n, p, all_roots)
     # The roots of ``x**n - a = 0 (mod p)`` are roots of
     # ``gcd(x**n - a, x**(p - 1) - 1) = 0 (mod p)``
     pa = n
     pb = p - 1
     b = 1
     if pa < pb:
         a, pa, b, pb = b, pb, a, pa
     while pb:
         # x**pa - a = 0; x**pb - b = 0
         # x**pa - a = x**(q*pb + r) - a = (x**pb)**q * x**r - a =
         #             b**q * x**r - a; x**r - c = 0; c = b**-q * a mod p
         q, r = divmod(pa, pb)
         c = pow(b, q, p)
         c = igcdex(c, p)[0]
         c = (c * a) % p
         pa, pb = pb, r
         a, b = b, c
     if pa == 1:
         if all_roots:
             res = [a]
[File updated. Please review the changes carefully and make sure they are correct (correct indentation, no duplicate or redundant lines etc). Edit the file again if necessary.]


============================================================



ACTION:

THOUGHT: The changes look correct. The diff shows:
1. Added the check for `a % p == 0` case right after parameter conversion
2. Returns `0` or `[0]` based on `all_roots` parameter
3. No duplicate code or indentation issues

Let's now test the changes with various test cases:
CODE:
CODE = """
from sympy.ntheory import nthroot_mod

# Test Case 1: a ≡ 0 (mod p), all_roots=False
print("Test 1: nthroot_mod(0, 2, 17) =", nthroot_mod(0, 2, 17))

# Test Case 2: a ≡ 0 (mod p), all_roots=True
print("Test 2: nthroot_mod(0, 2, 17, True) =", nthroot_mod(0, 2, 17, True))

# Test Case 3: Original PR case - when a % p == 0 indirectly
print("Test 3: nthroot_mod(17*17, 5, 17) =", nthroot_mod(17*17, 5, 17))

# Test Case 4: Regression test - ensure existing functionality works
print("Test 4: nthroot_mod(11, 4, 19) =", nthroot_mod(11, 4, 19))
print("Test 5: nthroot_mod(11, 4, 19, True) =", nthroot_mod(11, 4, 19, True))
"""
create_file("test_nthroot.py", CODE)

============================================================



OBSERVATION:

[File test_nthroot.py created.]
[File: /workspace/test_nthroot.py (15 lines total after edit)]
1|
2|from sympy.ntheory import nthroot_mod
3|
4|# Test Case 1: a ≡ 0 (mod p), all_roots=False
5|print("Test 1: nthroot_mod(0, 2, 17) =", nthroot_mod(0, 2, 17))
6|
7|# Test Case 2: a ≡ 0 (mod p), all_roots=True
8|print("Test 2: nthroot_mod(0, 2, 17, True) =", nthroot_mod(0, 2, 17, True))
9|
10|# Test Case 3: Original PR case - when a % p == 0 indirectly
11|print("Test 3: nthroot_mod(17*17, 5, 17) =", nthroot_mod(17*17, 5, 17))
12|
13|# Test Case 4: Regression test - ensure existing functionality works
14|print("Test 4: nthroot_mod(11, 4, 19) =", nthroot_mod(11, 4, 19))
15|print("Test 5: nthroot_mod(11, 4, 19, True) =", nthroot_mod(11, 4, 19, True))
[File updated. Please review the changes carefully and make sure they are correct (correct indentation, no duplicate or redundant lines etc). Edit the file again if necessary.]


============================================================



ACTION:

THOUGHT: The test file looks good. Let's run the tests:
COMMAND:
python3 test_nthroot.py

============================================================



OBSERVATION:

Test 1: nthroot_mod(0, 2, 17) = 0
Test 2: nthroot_mod(0, 2, 17, True) = [0]
Test 3: nthroot_mod(17*17, 5, 17) = 0
Test 4: nthroot_mod(11, 4, 19) = 8
Test 5: nthroot_mod(11, 4, 19, True) = [8, 11]



============================================================

